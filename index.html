<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Memcached面试题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/15/Memcached%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2025-05-15T04:18:21.000Z" itemprop="datePublished">2025-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/05/15/Memcached%E9%9D%A2%E8%AF%95%E9%A2%98/">Memcached面试题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="memcache缓存什么数据"><a href="#memcache缓存什么数据" class="headerlink" title="memcache缓存什么数据?"></a>memcache缓存什么数据?</h1><p>一、经常被读取并且实时性要求不强可以等到自动过期的数据。例如网站首页最新文章列表、某某排行等数据。</p>
<p>二、经常被读取并且实时性要求强的数据。比如用户的好友列表，用户文章列表，用户阅读记录等。</p>
<p>三、统计类缓存，比如文章浏览数、网站PV等。</p>
<p>四、活跃用户的基本信息或者某篇热门文章。</p>
<p>五、session数据</p>
<h1 id="memcache-和-Redis-的区别"><a href="#memcache-和-Redis-的区别" class="headerlink" title="memcache 和 Redis 的区别"></a>memcache 和 Redis 的区别</h1><p>数据结构：memcache仅支持简单的key-value形式，Redis支持的数据更多（string字符串，set集合，list列表，hash散列，zset有序集合）；<br>多线程：memcache支持多线程，Redis支持单线程<br>持久化：Redis支持持久化，memcache不支持持久化<br>分布式：Redis做主从结构，memcache服务器需要通过hash一致化来支撑主从结构</p>
<ol>
<li>Redis中，并不是所有的数据都一直存储在内存中的，这是和Memcache相比一个最大的区别。</li>
<li>Redis在很多方面具备数据库的特征，或者说就是一个数据库系统，而Memcache只是简单的K&#x2F;V缓存。</li>
<li>他们的扩展都需要做集群；实现方式：master-slave、Hash。</li>
<li>在100k以上的数据中，Memcache性能要高于Redis。</li>
<li>如果要说内存使用效率，使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcache。当然，这和你的应用场景和数据特性有关。</li>
<li>如果你对数据持久化和数据同步有所要求，那么推荐你选择Redis，因为这两个特性Memcache都不具备。即使你只是希望在升级或者重启系统后缓存数据不会丢失，选择Redis也是明智的。</li>
<li>Redis和Memcache在写入性能上面差别不大，读取性能上面尤其是批量读取性能上面Memcache更强</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/15/Memcached%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="cmb0z941k0000usume5hbffw0" data-title="Memcached面试题" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Redis面试题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/15/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2025-05-15T04:07:46.000Z" itemprop="datePublished">2025-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/05/15/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/">Redis面试题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="redis消息队列先进先出需要注意什么"><a href="#redis消息队列先进先出需要注意什么" class="headerlink" title="redis消息队列先进先出需要注意什么?"></a>redis消息队列先进先出需要注意什么?</h1><p>答:通常使用一个list来实现队列操作，这样有一个小限制，所以的任务统一都是先进先出，如果想优先处理某个任务就不太好处理了，这就需要让队列有优先级的概念，我们就可以优先处理高级别的任务，实现方式有以下几种方式：</p>
<p>1）单一列表实现：队列正常的操作是 左进右出（lpush,rpop）为了先处理高优先级任务，在遇到高级别任务时，可以直接插队，直接放入队列头部（rpush），这样，从队列头部（右侧）获取任务时，取到的就是高优先级的任务（rpop）</p>
<p>2）使用两个队列，一个普通队列，一个高级队列，针对任务的级别放入不同的队列，获取任务时也很简单，redis的BRPOP命令可以按顺序从多个队列中取值，BRPOP会按照给出的 key 顺序查看，并在找到的第一个非空 list 的尾部弹出一个元素，redis&gt; BRPOP list1 list2 0</p>
<p>list1 做为高优先级任务队列</p>
<p>list2 做为普通任务队列 </p>
<p>这样就实现了先处理高优先级任务，当没有高优先级任务时，就去获取普通任务 </p>
<p>方式1最简单，但实际应用比较局限，方式3可以实现复杂优先级，但实现比较复杂，不利于维护 </p>
<p>方式2是推荐用法，实际应用最为合适</p>
<h1 id="Redis如何防止高并发"><a href="#Redis如何防止高并发" class="headerlink" title="Redis如何防止高并发?"></a>Redis如何防止高并发?</h1><p>答：其实redis是不会存在并发问题的，因为他是单进程的，再多的命令都是一个接一个地执行的。我们使用的时候，可能会出现并发问题，比如获得和设定这一对。Redis的为什么 有高并发问题？Redis的的出身决定</p>
<p>Redis是一种单线程机制的nosql数据库，基于key-value，数据可持久化落盘。由于单线程所以redis本身并没有锁的概念，多个客户端连接并不存在竞争关系，但是利用jedis等客户端对redis进行并发访问时会出现问题。发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。</p>
<p>同时，单线程的天性决定，高并发对同一个键的操作会排队处理，如果并发量很大，可能造成后来的请求超时。</p>
<p>在远程访问redis的时候，因为网络等原因造成高并发访问延迟返回的问题。</p>
<p>解决办法</p>
<p>在客户端将连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。</p>
<p>服务器角度，利用setnx变向实现锁机制。</p>
<h1 id="redis和Memcached的区别到底是什么？"><a href="#redis和Memcached的区别到底是什么？" class="headerlink" title="redis和Memcached的区别到底是什么？"></a>redis和Memcached的区别到底是什么？</h1><ol>
<li>Redis是一个开源的内存数据结构存储，用作数据库，缓存和消息代理；</li>
<li>Memcached是一个免费的开源高性能分布式内存对象缓存系统，它通过减少数据库负载来加速动态Web应用程序。</li>
<li>Redis与Memcached相比，比仅支持简单的key-value数据类型，同时还提供list,set,zset,hash等数据结构的存储；redis支持数据的备份，redis支持数据的持久化，</li>
<li>总体来讲，TPS方面redis和memcache差不多，要大于mongodb。</li>
<li>内存使用效率对比：</li>
</ol>
<p>　　　　使用简单的key-value存储的话， Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。</p>
<ol>
<li>数据结构</li>
</ol>
<p>　　　　Redis支持字符串，散列，列表，集合，有序集，位图，超级日志和空间索引；而Memcached支持字符串和整数。</p>
<ol>
<li>执行速度</li>
</ol>
<p>　　　　Memcached的读写速度高于Redis。</p>
<ol>
<li>Redis是单线程的；而Memcached是多线程的。</li>
<li>数据一致性（事务支持）</li>
</ol>
<p>　　　　Memcache 在并发场景下，用cas保证一致性</p>
<p>　　　　redis事务支持比较弱，只能保证事务中的每个操作连续执行</p>
<p>　　　　mongoDB不支持事务</p>
<h1 id="什么是缓存击穿，穿透，雪崩？"><a href="#什么是缓存击穿，穿透，雪崩？" class="headerlink" title="什么是缓存击穿，穿透，雪崩？"></a>什么是缓存击穿，穿透，雪崩？</h1><p>　　（1）缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会被打到数据库上。</p>
<p>　　解决：</p>
<p>　　　　1，缓存空对象</p>
<p>　　　　2、布隆过滤器</p>
<p>　　（2）缓存击穿是指热点key在某个时间点过期的时候，而恰好在这个时间点对这个Key有大量的并发请求过来，从而大量的请求打到db，属于常见的“热点”问题</p>
<p>　　解决：</p>
<p>　　　　1.预先设置热门数据，提前存入缓存</p>
<p>　　　　2.实时监控热门数据，调整key过期时长</p>
<p>　　　　3.二级缓存:对于热点数据进行二级缓存，并对于不同级别的缓存设定不同的失效时间。</p>
<p>　　　　4.设置分布式锁</p>
<p>　　（3）大量的应用请求无法在Redis缓存中进行处理，紧接着应用将大量请求发送到数据库层，导致数据库层的压力激增</p>
<p>　　　　击穿与雪崩的区别即在于击穿是对于特定的热点数据来说，而雪崩是全部数据。</p>
<p> 　  解决：</p>
<p>　　　　1、差异化设置过期时间</p>
<p>　　　　2、不设置过期时间</p>
<p>　　　　3、服务降级</p>
<h1 id="redis和memcache有什么区别"><a href="#redis和memcache有什么区别" class="headerlink" title="redis和memcache有什么区别"></a>redis和memcache有什么区别</h1><p>多线程：memcache支持多线程，Redis支持单线程</p>
<p>持久化：Redis支持持久化(周期性的将数据写到磁盘中)，memcache不支持持久化</p>
<p>分布式：Redis做主从结构，memcache服务器需要通过hash一致化来支撑主从结构</p>
<h1 id="redis常见数据结构有哪些"><a href="#redis常见数据结构有哪些" class="headerlink" title="redis常见数据结构有哪些"></a>redis常见数据结构有哪些</h1><p>最常用的的有5种,字符串(String)、哈希(Hash)、列表(list)、集合(set)、有序集合(ZSET)</p>
<h1 id="redis缓存雪崩、缓存穿透、缓存击穿"><a href="#redis缓存雪崩、缓存穿透、缓存击穿" class="headerlink" title="redis缓存雪崩、缓存穿透、缓存击穿"></a>redis缓存雪崩、缓存穿透、缓存击穿</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/t707584896/article/details/128812799">https://blog.csdn.net/t707584896/article/details/128812799</a></p>
<h1 id="redis淘汰策略"><a href="#redis淘汰策略" class="headerlink" title="redis淘汰策略"></a>redis淘汰策略</h1><p>volatile-lru，针对设置了过期时间的key，使用lru算法进行淘汰。</p>
<p>allkeys-lru，针对所有key使用lru算法进行淘汰。</p>
<p>volatile-lfu，针对设置了过期时间的key，使用lfu算法进行淘汰。</p>
<p>allkeys-lfu，针对所有key使用lfu算法进行淘汰。</p>
<p>volatile-random，从所有设置了过期时间的key中使用随机淘汰的方式进行淘汰。</p>
<p>allkeys-random，针对所有的key使用随机淘汰机制进行淘汰。</p>
<p>volatile-ttl，删除生存时间最近的一个键。</p>
<p>noeviction(默认)，不删除键，值返回错误。</p>
<h1 id="redis分布式锁怎么实现"><a href="#redis分布式锁怎么实现" class="headerlink" title="redis分布式锁怎么实现"></a>redis分布式锁怎么实现</h1><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/300767410/answer/1931519430">https://www.zhihu.com/question/300767410/answer/1931519430</a></p>
<h1 id="Redis的持久化机制"><a href="#Redis的持久化机制" class="headerlink" title="Redis的持久化机制"></a>Redis的持久化机制</h1><p>区别：</p>
<p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程就是有一个fork子进程，先将数据集写入到临时文件中，写入成功后，再替换之前的文件，用二进制压缩存储。</p>
<p>AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</p>
<p>RDB的优缺点：</p>
<p>优点：RDB持久化文件，速度比较快，而且存储的是一个二进制文件，传输起来很方便。</p>
<p>缺点：RDB无法保证数据的绝对安全，有时候就是1s也会有很大的数据丢失。</p>
<p>AOF的优缺点：</p>
<p>优点：AOF相对RDB更加安全，一般不会有数据的丢失或者很少，官方推荐同时开启AOF和RDB。</p>
<p>缺点：AOF持久化的速度，相对于RDB较慢，存储的是一个文本文件，到了后期文件会比较大，传输困难。</p>
<h1 id="redis如何解决秒杀超卖问题"><a href="#redis如何解决秒杀超卖问题" class="headerlink" title="redis如何解决秒杀超卖问题"></a>redis如何解决秒杀超卖问题</h1><p>队列、事物、分布式锁等很多方式，自行了解</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/268290754">https://zhuanlan.zhihu.com/p/268290754</a></p>
<h1 id="MySQL里有2000w数据-redis中只存20w数据-如何保证redis中数据都是热点数据"><a href="#MySQL里有2000w数据-redis中只存20w数据-如何保证redis中数据都是热点数据" class="headerlink" title="MySQL里有2000w数据,redis中只存20w数据,如何保证redis中数据都是热点数据"></a>MySQL里有2000w数据,redis中只存20w数据,如何保证redis中数据都是热点数据</h1><p>分析题目：保证Redis 中的 20w 数据都是热点数据 说明是被频繁访问的数据，并且要保证Redis的内存能够存放20w数据，要计算出Redis内存的大小。</p>
<p>a、保留热点数据：对于保留 Redis 热点数据来说，我们可以使用 Redis 的内存淘汰策略来实现，可以使用allkeys-lru淘汰策略，该淘汰策略是从 Redis 的数据中挑选最近最少使用的数据删除，这样频繁被访问的数据就可以保留下来了。</p>
<p>b、保证 Redis 只存20w的数据：1个中文占2个字节，假如1条数据有100个中文，则1条数据占200字节，20w数据 乘以 200字节 等于 4000 字节（大概等于38M）;所以要保证能存20w数据，Redis 需要38M的内存。</p>
<h1 id="redis主从哨兵和集群的区别"><a href="#redis主从哨兵和集群的区别" class="headerlink" title="redis主从哨兵和集群的区别"></a>redis主从哨兵和集群的区别</h1><p>一、架构不同</p>
<p>　　redis主从：一主多从；</p>
<p>　　redis集群：多主多从；</p>
<p>二、存储不同</p>
<p>　　redis主从：主节点和从节点都是存储所有数据；</p>
<p>　　redis集群：数据的存储是通过hash计算16384的槽位，算出要将数据存储的节点，然后进行存储；</p>
<p>三、选举不同</p>
<p>　　redis主从：通过启动redis自带的哨兵（sentinel）集群进行选举，也可以是一个哨兵</p>
<p>　　　　选举流程：1、先发现主节点fail的哨兵，将成为哨兵中的leader，之后的主节点选举将通过这个leader进行故障转移操作，从存活的slave中选举新的master，新的master选举同集群的master节点选举类似；</p>
<p>　　redis集群：集群可以自己进行选举</p>
<p>　　　　选举流程：1、当主节点挂掉，从节点就会广播该主节点fail；</p>
<p>　　　　　　　　　2、延迟时间后进行选举（延迟的时间算法为：延迟时间+随机数+rank*1000，从节点数据越多，rank越小，因为主从数据复制是异步进行的，所以　　所有的从节点的数据可能会不同），延迟的原因是等待主节点fail广播到所有存活的主节点，否则主节点会拒绝参加选举；</p>
<p>　　　　　　　　　3、参加选举的从节点向所有的存活的节点发送ack请求，但只有主节点会回复它，并且主节点只会回复第一个到达参加选举的从节点，一半以上的主节点回复，该节点就会成为主节点，广播告诉其他节点该节点成为主节点。</p>
<p>四、节点扩容不同</p>
<p>　　redis主从：只能扩容从节点，无法对主节点进行扩容；</p>
<p>　　redis集群：可以扩容整个主从节点，但是扩容后需要进行槽位的分片，否则无法进行数据写入，命令为：</p>
<p>　　　　&#x2F;usr&#x2F;local&#x2F;redis-5.0.3&#x2F;src&#x2F;redis-cli -a zhuge –cluster reshard 192.168.0.61:8001，其中的192.168.0.61:8001为新加入的主从节点；</p>
<h1 id="redis消息队列如何防止数据丢失"><a href="#redis消息队列如何防止数据丢失" class="headerlink" title="redis消息队列如何防止数据丢失"></a>redis消息队列如何防止数据丢失</h1><p>Redis实现消息队列有两种形式：</p>
<p>广播订阅模式：基于Redis的 Pub&#x2F;Sub 机制，一旦有客户端往某个key里面 publish一个消息，所有subscribe的客户端都会触发事件</p>
<p>集群订阅模式：基于Redis List双向+ 原子性 + BRPOP</p>
<p>Redis消息队列时，当Redis宕机后，消息可能会丢失（也要看持久化的策略）。如果收消息方(消费端)未有重发和验证机制，Redis内的数据会出现丢失。所以，使用Redis的作为消息队列，通常是对于消息的准确性并非特别高的场景。</p>
<p>如果绝对的保证数据最终一致性，保证消息百分百不丢，那么需要：</p>
<p>1.写入时候要求启用事务处理，保证写一定成功。</p>
<ol start="2">
<li>redis配置成任何变更一定实时持久化，比如存储端是磁盘的话，每次变更马上同步写入磁盘，才算完成。redis是支持这种方式配置的，但是这么做会使它的内存数据库特性完全消失，性能变得十分低下。</li>
<li>消费端也要实现事务方式，处理完成后，再回来真实删除消息。</li>
<li>多线程或者多端同时并发处理，可以通过锁的方式来规避。</li>
</ol>
<p>3 4的需求需要自己实现，可以一起考虑，用另外一个队列实现的方式也可以，但是更好的方式是在队列内部实现个计数器。hash格式的加个字段加数值，list的先推一个数值打底，string的头上加个数值再加个分隔符，就可以做个简单计数器了，虽然土，胜在够实用。</p>
<p>除了特定的系统之外，一般不会要求这么强的一致性，实现倒不难，但是性能会很差很差。</p>
<p>银行类支付类业务会要求严格的事务一致性，而互联网类业务一般会用点取巧的方式，就是可以容忍极短时间内少量数据丢失的方式，换取更高性能。</p>
<p>比如上面的redis处理，可以改为1000条数据变更的时候再真实落盘，即写入磁盘。那么极限情况下，如突然断电，存在可能丢失这1000条数据的风险。当然这种情况出现的概率也是很低的（远离蓝翔挖掘机？），所以大部分场景下可以接受。</p>
<h1 id="MQ消息队列你怎么选择，各大优劣"><a href="#MQ消息队列你怎么选择，各大优劣" class="headerlink" title="MQ消息队列你怎么选择，各大优劣"></a>MQ消息队列你怎么选择，各大优劣</h1><p>1 RabbitMQ</p>
<p>优点：轻量级、容易部署和使用、支持多种客户端开发语言、支持灵活的路由配置</p>
<p>缺点：对消息堆积的支持并不好、性能和吞吐量较差、使用 Erlang 语言编写，比较难进行二次开发</p>
<p>2 RocketMQ</p>
<p>优点：性能好、稳定可靠、有活跃的中文社区、使用 Java 开发，容易进行二次开发、特点响应快</p>
<p>缺点：兼容性较差</p>
<p>3 Kafka</p>
<p>优点：兼容性极好、设计上大量使用了批量和异步的思想，有超高的性能、</p>
<p>缺点：由于 “先攒一波再一起处理” 的设计，时延较高，不太适合在线业务场景</p>
<p>4 总结</p>
<p>如果说，消息队列并不是你将要构建的主角之一，对消息队列的功能和性能都没有很高的要求，只需要一个开箱即用易于维护的产品，建议使用 RabbitMQ。</p>
<p>如果系统使用消息队列的主要场景是处理在线业务，比如在交易系统中用消息队列传递订单，那 RocketMQ 的低延迟和金融级的稳定性是我们需要的。</p>
<p>如果需要的是处理海量的数据，像收集日志、监控信息或是前端的埋点这类数据，或是应用场景大量使用了大数据、流计算相关的开源产品，那 Kafka 是最适合的消息队列。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/15/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="cmb0z941t0004usum1zhp7aws" data-title="Redis面试题" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Nginx面试题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/15/Nginx%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2025-05-15T03:12:51.000Z" itemprop="datePublished">2025-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/05/15/Nginx%E9%9D%A2%E8%AF%95%E9%A2%98/">Nginx面试题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Nginx和Apache"><a href="#Nginx和Apache" class="headerlink" title="Nginx和Apache"></a>Nginx和Apache</h1><p>Apache：稳定、动态处理优于nginx、占内存大、重写机制好<br>Nginx：并发能力强、占内存小、静态资源处理好、10万并发、配置简单</p>
<h2 id="Nginx相对于Apache的优势"><a href="#Nginx相对于Apache的优势" class="headerlink" title="Nginx相对于Apache的优势"></a>Nginx相对于Apache的优势</h2><p>1.轻量级，采用C进行编写，同样的web服务，会占用更少的内存及资源<br>2.抗并发，nginx以epoll and kqueue作为开发模型，处理请求是异步非阻塞的，多个连接对应一个进程，<br>负载能力比apache高很多，而apache则是同步多进程模型，只能一个连接对应一个进程，当压力过大时，它是会被阻塞型的。在高并发下nginx能保持低资源低消耗高性能 ，而apache在PHP处理慢或者前端压力很大的情况下，很容易出现进程数飙升，从而拒绝服务的现象。<br>3.设计高度模块化，编写模块相对简单<br>4.配置简洁，正则配置让很多事情变得简单，而且改完配置能使用 -t 测试配置有没有问题，<br>apache 配置复杂 ，重启的时候发现配置出错了，会很崩溃<br>5.一般用于处理静态文件，静态处理性能比apache高三倍以上<br>6.作为负载均衡服务器，支持7层负载均衡<br>7.本身就是一个反向代理服务器，而且可以作为非常优秀的邮件代理服务器<br>8.nginx启动特别容易, 并且几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动，<br>支持热部署，比如：实现不间断服务的情况下进行软件版本的升级与版本的回退<br>9.社区活跃，各种高性能模块出品迅速</p>
<h2 id="Apache相对于Nginx的优势"><a href="#Apache相对于Nginx的优势" class="headerlink" title="Apache相对于Nginx的优势"></a>Apache相对于Nginx的优势</h2><p>1.apache的rewrite比nginx强大，在rewrite频繁的情况下，用apache<br>2.apache发展到现在，模块超多，基本想到的都可以找到<br>3.apache更为成熟，少bug ，nginx的bug相对较多<br>4.apache超稳定，nginx稳定性差<br>5.apache对PHP支持比较简单，nginx需要配合其他后端用<br>6.apache在处理动态请求有优势，nginx在这方面是鸡肋，一般动态请求要apache去做，nginx适合静态和反向。<br>7.apache仍然是目前的主流，拥有丰富的特性，成熟的技术和开发社区</p>
<h2 id="两者最核心的区别"><a href="#两者最核心的区别" class="headerlink" title="两者最核心的区别"></a>两者最核心的区别</h2><p>Apache是同步多进程模型，一个连接对应一个进程</p>
<p>Nginx是异步的，多个连接（万级别）可以对应一个进程。</p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>一般来说，需要性能的web服务，用Nginx；如果不需要性能只求稳定，更考虑Apache；<br>Nginx处理放静态内容比Apache要好，特别是在可承受压力、带宽及资源消耗上都要优于Apache。<br>所以更为通用的方案是，前端Nginx抗并发，后端Apache集群，配合起来会更好。</p>
<h1 id="Nginx报错502"><a href="#Nginx报错502" class="headerlink" title="Nginx报错502"></a>Nginx报错502</h1><p>http请求流程：一般情况下，提交动态请求的时候，nginx会直接把 请求转交给php-fpm，而php-fpm再分配php-cgi进程来处理相关的请求，之后再依次返回，最后由nginx把结果反馈给客户端浏览器。</p>
<p>Nginx 502 Bad Gateway错误是FastCGI有问题</p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a><strong>解决办法</strong></h4><p>遇到502问题，可以优先考虑按照以下两个步骤去解决。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">1、查看当前的PHP FastCGI进程数是否够用（max_children值）</span><br><span class="line">netstat -anpo | grep &quot;php-cgi&quot;| wc -l</span><br><span class="line">如果实际使用的“FastCGI进程数”接近预设的“FastCGI进程数”，那么，说明“FastCGI进程数”不够用，需要增大。</span><br><span class="line"></span><br><span class="line">2、部分PHP程序的执行时间超过了Nginx的等待时间（php内存不足）</span><br><span class="line">增加nginx.conf配置文件中FastCGI的timeout时间，例如：</span><br><span class="line">    fastcgi_connect_timeout 300;</span><br><span class="line">    fastcgi_send_timeout 300;</span><br><span class="line">    fastcgi_read_timeout 300;</span><br><span class="line">php.ini中的memory_limit=64M，重启nginx。</span><br><span class="line"></span><br><span class="line">如果这样修改了还解决不了问题，可以参考下面这些方案：</span><br><span class="line">3、max-children和max-requests</span><br><span class="line">一台服务器上运行着nginx php(fpm) xcache，访问量日均 300W pv左右</span><br><span class="line">最近经常会出现这样的情况： </span><br><span class="line">php页面打开很慢，cpu使用率突然降至很低，系统负载突然升至很高，查看网卡的流量，也会发现突然降到了很低。这种情况只持续数秒钟就恢复了</span><br><span class="line">检查php-fpm的日志文件发现了一些线索：</span><br><span class="line"></span><br><span class="line">    Sep3008:32:23.289973[NOTICE] fpm_unix_init_main(), line 271: getrlimit(nofile): max:51200,cur:51200</span><br><span class="line">    Sep3008:32:23.290212[NOTICE] fpm_sockets_init_main(), line 371:using inherited socket fd=10,“127.0.0.1:9000″</span><br><span class="line">    Sep3008:32:23.290342[NOTICE] fpm_event_init_main(), line 109: libevent:using epoll</span><br><span class="line">    Sep3008:32:23.296426[NOTICE] fpm_init(), line 47: fpm is running, pid 30587</span><br><span class="line"></span><br><span class="line">在这几句的前面，是1000多行的关闭children和开启children的日志</span><br><span class="line">原来，php-fpm有一个参数 max_requests，该参数指明了，每个children最多处理多少个请求后便会被关闭，默认的设置是500。</span><br><span class="line">因为php是把请求轮询给每个children，在大流量下，每个childre到达max_requests所用的时间都差不多，这样就造成所有的children基本上在同一时间被关闭。</span><br><span class="line">在这期间，nginx无法将php文件转交给php-fpm处理，所以cpu会降至很低(不用处理php，更不用执行sql)，而负载会升至很高(关闭和开启children、nginx等待php-fpm)，</span><br><span class="line">网卡流量也降至很低(nginx无法生成数据传输给客户端)</span><br><span class="line"></span><br><span class="line">增加children的数量，并且将 max_requests 设置未 0 或者一个比较大的值：</span><br><span class="line"></span><br><span class="line">打开 /usr/local/php/etc/php-fpm.conf</span><br><span class="line"></span><br><span class="line">调大以下两个参数(根据服务器实际情况，过大也不行）</span><br><span class="line"></span><br><span class="line">    &lt;valuename=”max_children”&gt;5120&lt;/value&gt;</span><br><span class="line">    &lt;valuename=”max_requests”&gt;600&lt;/value&gt;</span><br><span class="line"></span><br><span class="line">然后重启php-fpm。</span><br><span class="line">5、增加缓冲区容量大小</span><br><span class="line">将nginx的error log打开，发现“pstream sent too big header while reading response header from upstream”这样的错误提示。</span><br><span class="line">查阅了一下资料，大意是nginx缓冲区有一个bug造成的,我们网站的页面消耗占用缓冲区可能过大。参考老外写的修改办法增加了缓冲区容量大小设置，502问题彻底解决。</span><br><span class="line">后来系统管理员又对参数做了调整只保留了2个设置参数：client head buffer，fastcgi buffer size。</span><br><span class="line"></span><br><span class="line">6、request_terminate_timeout</span><br><span class="line">如果主要是在一些post或者数据库操作的时候出现502这种情况，而不是在静态页面操作中常见，那么可以查看一下php-fpm.conf设置中的一项：</span><br><span class="line">request_terminate_timeout</span><br><span class="line"></span><br><span class="line">这个值是max_execution_time，就是fast-cgi的执行脚本时间。</span><br><span class="line">0s为关闭，就是无限执行下去。（当时装的时候没仔细看就改了一个数字）</span><br><span class="line"></span><br><span class="line">优化fastcgi中，还可以改改这个值5s 看看效果。</span><br><span class="line">php-cgi进程数不够用、php执行时间长、或者是php-cgi进程死掉，都会出现502错误。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Nginx的报错500"><a href="#Nginx的报错500" class="headerlink" title="Nginx的报错500"></a>Nginx的报错500</h1><h3 id="500：服务器内部错误，也就是服务器遇到意外情况，而无法履行请求。"><a href="#500：服务器内部错误，也就是服务器遇到意外情况，而无法履行请求。" class="headerlink" title="500：服务器内部错误，也就是服务器遇到意外情况，而无法履行请求。"></a><strong>500：服务器内部错误，也就是服务器遇到意外情况，而无法履行请求。</strong></h3><h3 id="500错误一般有几种情况："><a href="#500错误一般有几种情况：" class="headerlink" title="500错误一般有几种情况："></a>500错误一般有几种情况：</h3><p>\1. web脚本错误，如php语法错误，lua语法错误等。</p>
<p>\2. 访问量大的时候，由于系统资源限制，而不能打开过多的文件</p>
<h3 id="一般分析思路："><a href="#一般分析思路：" class="headerlink" title="一般分析思路："></a>一般分析思路：</h3><p>（1）查看nginx error log ，查看php error log</p>
<p>（2）如果是too many open files，修改nginx的worker_rlimit_nofile参数，使用ulimit查看系统打开文件限制，修改&#x2F;etc&#x2F;security&#x2F;limits.conf</p>
<p>（3）如果是脚本的问题，则需要修复脚本错误，并优化代码</p>
<p>（4）各种优化都做好，还是出现too many open files，那就要考虑做负载均衡，把流量分散到不同服务器上去了。</p>
<h3 id="错误原因总结："><a href="#错误原因总结：" class="headerlink" title="错误原因总结："></a>错误原因总结：</h3><p>1、硬盘空间满了 </p>
<p>使用 df -h 查看硬盘空间是否满了。清理硬盘空间就可以解决500错误。</p>
<p>nginx如果开启了access log，在不需要的情况下，最好关闭access log。access log会占用大量硬盘空间。 </p>
<p>2、nginx配置文件错误 </p>
<p>这里不是指语法错误，nginx如果配置文件有语法错误，启动的时候就会提示。当配置rewrite的时候，有些规则处理不当会出现500错误，请仔细检查自己的rewrite规则。如果配置文件里有些变量设置不当，也会出现500错误，比如引用了一个没有值的变量。 </p>
<p>3、如果上面的问题都不存在可能是模拟的并发数太多了，需要调整一下nginx.conf的并发设置数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">解决方法是：1 打开/etc/security/limits.conf文件，加上两句</span><br><span class="line">复制代码代码如下:</span><br><span class="line">* soft nofile 65535 </span><br><span class="line">* hard nofile 65535 </span><br><span class="line"></span><br><span class="line">2 打开/etc/nginx/nginx.conf </span><br><span class="line">在worker_processes的下面增加一行</span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line"></span><br><span class="line">3 重新启动nginx，重新载入设置 </span><br><span class="line">复制代码代码如下:</span><br><span class="line">kill -9 `ps -ef | grep php | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;` </span><br><span class="line">/usr/bin/spawn-fcgi -a 127.0.0.1 -p 9000 -C 100 -u www-data -f /usr/bin/php-cgi </span><br><span class="line">killall -HUP nginx </span><br><span class="line">重启后再看nginx的错误日志，也没有发现500报错的情况了。 </span><br><span class="line"></span><br><span class="line">4、有可能是数据库问题我的在nginx日志php日志都没有发现什么问题, 最后发现数据库访问不了,修正后问题解决。</span><br></pre></td></tr></table></figure>

<h1 id="Nginx报错504"><a href="#Nginx报错504" class="headerlink" title="Nginx报错504"></a>Nginx报错504</h1><p>Nginx 504错误(Gateway time-out  网关超时)的含义是所请求的网关没有请求到，简单来说就是没有请求到可以执行的PHP-CGI。</p>
<p>一般看来, 这种情况可能是由于nginx默认的fastcgi进程响应的缓冲区太小造成的, 这将导致fastcgi进程被挂起, 如果你的fastcgi服务对这个挂起处理的不好, 那么最后就极有可能导致504 Gateway Time-out。<br>现在的网站, 尤其某些论坛有大量的回复和很多内容的, 一个页面甚至有几百K，默认的fastcgi进程响应的缓冲区是8K, 我们可以设置大点，</p>
<p>在nginx.conf里, 加入:</p>
<p><strong>fastcgi_buffers 8 128k</strong></p>
<p>这表示设置fastcgi缓冲区为<strong>8×128k</strong><br>当然如果您在进行某一项即时的操作, 可能需要nginx的超时参数调大点, 例如设置成60秒:</p>
<p><strong>send_timeout 60;</strong></p>
<h3 id="Nginx-502与504的区别："><a href="#Nginx-502与504的区别：" class="headerlink" title="Nginx 502与504的区别："></a>Nginx 502与504的区别：</h3><p>Nginx 502 Bad Gateway的含义是请求的PHP-CGI已经执行，但是由于某种原因(一般是读取资源的问题)没有执行完毕而导致PHP-CGI进程终止。</p>
<p>Nginx 504 Gateway Time-out的含义是所请求的网关没有请求到，简单来说就是没有请求到可以执行的PHP-CGI。</p>
<p>解决这两个问题其实是需要综合思考的，一般来说Nginx 502 Bad Gateway和php-fpm.conf的设置有关，而Nginx 504 Gateway Time-out则是与nginx.conf的设置有关。</p>
<h1 id="nginx和apache的区别？"><a href="#nginx和apache的区别？" class="headerlink" title="nginx和apache的区别？"></a>nginx和apache的区别？</h1><p>　　（1）二者最核心的区别在于apache是同步多进程模型，一个连接对应一个进程；nginx是异步的，多个连接（万级别）可以对应一个进程 。nginx处理静态文件好,耗费内存少.但无疑apache仍然是目前的主流,有很多丰富的特性.所以还需要搭配着来.当然如果能 确定nginx就适合需求,那么使用nginx会是更经济的方式。</p>
<p>　　（2）nginx的负载能力比apache高很多。最新的服务器也改用nginx了。而且nginx改完配置能-t测试一下配置有没有问题。</p>
<p>　　（3）apache重启的时候发现配置出错了，会很崩溃，改的时候都会非常小心翼翼现在看有好多集群站，前端nginx抗并发，后端apache集群， 配合的也不错。</p>
<p>　　（4）nginx处理动态请求是鸡肋，一般动态请求要apache去做，nginx只适合静态和反向。</p>
<p>　　（5）从经验来看，nginx是很不错的前端服务器，负载性能很好，nginx，用webbench模拟10000个静态文件请求毫不吃力。 apache对php等语言的支持很好，此外apache有强大的支持网络，发展时间相对nginx更久，bug少但是apache有先天不支持多核心处 理负载鸡肋的缺点，建议使用nginx做前端，后端用apache。大型网站建议用nginx自代的集群功能。</p>
<p>　　（6）大部分情况下nginx都优于APACHE，比如说静态文件处理、PHP-CGI的支持、反向代理功能、前端 Cache、维持连接等等。在Apache+PHP（prefork）模式下，如果PHP处理慢或者前端压力很大的情况下，很容易出现Apache进程数 飙升，从而拒绝服务的现象。</p>
<p>　　（7）Apache在处理动态有优势，Nginx并发性比较好，CPU内存占用低，如果rewrite频繁，那还是Apache吧！</p>
<p>　　（8）一般来说，需要性能的web 服务，用nginx 。如果不需要性能只求稳定，那就apache 吧。</p>
<h1 id="nginx实现高并发的原理"><a href="#nginx实现高并发的原理" class="headerlink" title="nginx实现高并发的原理?"></a>nginx实现高并发的原理?</h1><ol>
<li>nginx高并发原理(多进程+epoll实现高并发)</li>
</ol>
<p>　　　　（1）Nginx 在启动后，会有一个 master 进程和多个相互独立的 worker 进程</p>
<p>　　　　（2）每个子进程只有一个线程，采用的 IO多路复用模型epoll，实现高并发</p>
<ol>
<li>epoll能实现高并发原理</li>
</ol>
<p>　　　　（1）epoll() 中内核则维护一个链表，epoll_wait 方法可以获取到链表长度，不为0就知道文件描述符准备好了</p>
<p>　　　　（2）在内核实现中 epoll 是根据每个 sockfd 上面的与设备驱动程序建立起来的回调函数实现的</p>
<p>　　　　（3）某个 sockfd 上的事件发生时，与它对应的回调函数就会被调用，来把这个 sockfd 加入链表，其他处于“空闲的”状态的则不会</p>
<p>　　　　（4）epoll上面链表中获取文件描述，这里使用内存映射（mmap）技术， 避免了复制大量文件描述符带来的开销</p>
<p>　</p>
<h1 id="什么是防盗链？"><a href="#什么是防盗链？" class="headerlink" title="什么是防盗链？"></a>什么是防盗链？</h1><p>　　了解防盗链之前先了解下http referer这个属性，http referer是请求头中的一部分，当浏览器向web服务器发出请求时，一般会带上这个属性用来表明网页的来源，比如我在qq空间里添加朋友的空间链接，那么当有人点击我空间里的这个链接调到朋友的qq空间时，referer的值就是我空间的url。防盗链的基本原理就是根据请求头中referer属性得到网页来源，从而实现访问控制在nginx里的location里设置。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/15/Nginx%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="cmb0z941p0001usum109f4q1k" data-title="Nginx面试题" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-MySQL面试题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/15/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2025-05-15T03:12:39.000Z" itemprop="datePublished">2025-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/05/15/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/">MySQL面试题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="mysql的执行过程："><a href="#mysql的执行过程：" class="headerlink" title="mysql的执行过程："></a>mysql的执行过程：</h1><p>server层</p>
<ul>
<li>连接器（权限校验）</li>
<li>分析器（判断sql语法，有的话执行缓存）</li>
<li>优化器（判断何时的索引）</li>
<li>执行器-&gt;返回结果</li>
</ul>
<p>存储引擎层</p>
<ul>
<li>存储数据，提供读写接口如innodb,mysaim,memory</li>
</ul>
<p>聚合函数执行顺序：<br>SQL：SELECT age,count(age) as enum FROM people where age&lt;&gt;‘’ GROUP BY age HAVING enum&gt;100 order by enum desc;<br>顺序： where group having order (先where运算，得到符合条件的数据，进行group操作，再having筛选group的值，最后排序)</p>
<p>数据库设计三大范式：<br>第一范式（1NF）（每一列都不可分割）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。<br>第二范式（2NF） (完全依赖于主键) 简而言之，第二范式就是属性完全依赖于主键。<br>第三范式（3NF） 任何字段不能由其他字段派生出来，它要求字段没有冗余<br>锁的分类：<br>通过锁定范围：行级锁（innodb）和表级锁（myisam）<br>通过锁定类型：排它锁和共享锁<br>排他锁：[for update] innodb除select的操作都会排它锁]锁定后，用select还是能读取，但是无法再给数据加共享锁和排它锁（一行不能同时存在两个锁）<br>select * from table where xxx for update<br>共享锁：[ lock in share mode] 锁定后，除了排它锁，其他都可以加上<br>select * from tb_test where id &#x3D; 1 lock in share mode;<br>（InnoDB 引擎中的四种隔离级别就是用 排他锁 + 共享锁 实现的）<br>mysql<br>innodb和myisam是存储格式：<br>myisam:<br>.frm: 存储表定义<br>.myd(MYData):存储数据<br>.MYI(MYindex):索引的数据树。<br>（索引和数据是分开存放的，索引数上只存了数据的物理地址）</p>
<p>innodb:<br>.frm:存储表定义<br>.ibd:存储数据和索引,在同一个文件中</p>
<p>innodb和myisam引擎的区别：<br>innodb是聚簇索引：索引和数据是放一起的<br>mysaim非聚集(局促)索引：任何情况下都必须回表查询，因为MyISAM索引文件和数据文件是分离的。<br>详细介绍<br>b+树和b树的区别：<br>innodb和myisam都是b+树实现，只是底层innodb用的是主键，myisam用的是随机是生成的。b+树&#x3D;聚簇索引+非聚簇索引</p>
<p>b 所有层之间key不重复，所有层上的节点都放着数据，找到就跳出<br>b+ 所有层之间key会重复，只有最底层的才带数据<br>b+树的优点：<br>单一节点存储更多的元素，使得查询的IO次数更少。<br>所有查询都要查找到叶子节点，查询性能稳定。<br>所有叶子节点形成有序链表，便于范围查询。<br>如何优化这句sql :<br>原：select uid from user limit 7000000,10：<br>新：select uid from user where id&gt;700000000 limit 10;（第一个要扫描700000行）</p>
<p>hash索引的特点：<br>在等值的情况下比btree效率更高（重复的不多的情况下），不支持排序，需要回表查询</p>
<p>聚集索引和非聚集索引：<br>在非聚集索引通过name取得性别，就需要先拿到叶上的主键id，再拿着id去主键b+树的聚集索引里找</p>
<p>聚集索引：就是按照每张表的主键构造一棵B+ 树，它的叶子节点存放的是整行数据，叶上的数据如”id,name,age,sex”等全部数据<br>非聚集索引:比如给name建了一个普通索引，那么就生产一棵树B+树，它的叶子上只有”name,id”<br>什么是索引覆盖:<br>联合索引是一棵树上,数据”骷大人,29”，两棵树的话肯定又要走一遍流程了，需遵从最左原则</p>
<p>比如我用户表有三个索引，一个id的聚簇索引，一个身份证的唯一索引，一个用户名的普通索引，那么会建立3棵索引树，<br>第一个树的叶上有id&#x3D;1 idcard&#x3D;123 name&#x3D;kudaren 等全部数据·(主键的聚集索引)，第二棵树 idcard&#x3D;123，id&#x3D;1，第三棵树name&#x3D;kudaren id&#x3D;1·(两个普通的非聚集索引)，第一个数可以拿到全部数据，而其他的需要拿着id再查一次（拿id去索引树查）<br>如果解决普通索引二次查找的问题，建立联合索引，name，和age ，select name,age from tabe where name&#x3D;‘xx’<br>如何实现索引覆盖:<br>尽量使用主键查询，因为inodb是聚簇索引（聚簇索引上存了行的全部内容），不需要回表，<br>退一步做普通索引的覆盖<br>1.联合索引a和b搜索a直接拿到b，<br>2.先拿到主键id，再去聚簇索引通过id搜索数据。<br>索引的分类：<br>按类型：unique（唯一），normal（普通）<br>按方法：btree（b+树），hash（哈希）<br>普通索引，全文索引，联合索引<br>主键索引，唯一索引（区别是后者允许为空）</p>
<p>如何合适的使用索引：<br>给经常用到的字段，增加索引，然后使用的时候也要避免比如is null,&lt;&gt;,like啊等操作,in的话尽量用between代替。<br>经常用到的组合搜索可以增加联合索引，秉持最左原则，越常用的字段越前面。比如你加的是a,b 搜索的时候却搜了b,a<br>用explain来看一下这条sql的索引应用效果。<br>当字段操作大于读取的情况也不建议加索引，主键建议设置成自增。<br>重复性较高的，比如性别1，2也不建议加索引。<br>索引会失效的情况：<br>网上说的between替换成in是错的，事实是如果between 1 and 100 是可以的，但 1 and 100000000000就不走了，优化器的聪明之处</p>
<p>联合索引没有秉持最左原则。<br>索引只用到了一部分，因为联合索引从左到右执行到&lt; 或者&gt;的区间查询的时候停止，那么建立了a,b,c,d,然后c做了一个区间查询，那么d就用不到，可以吧索引改成a,b,d,c<br>sql中用了mysql的内置函数<br>用了%like,or等操作<br>以下情况索引是否使用：<br>现有user表，建立了联合索引a,b,c</p>
<p>问：select * from user where c&#x3D;4 and b&#x3D;6 and a&#x3D;3;<br>答：mysql的优化器很聪明，会在内部转换sql，所以会用到索引</p>
<p>问：select * from user where a&#x3D;3 order by c;<br>答：a索引用到了，c没用到，explain看到filesort，如c改成b不会有</p>
<p>字段的数据类型：<br>新增字段你的时候选择合适的数据类型，字段大小估计一个合适的不要选的很大，<br>用内置的日期和时间类型存储时间，用整型存储ip地址<br>应尽量将字段设置成not null，null对索引不友好，用0或者空字符来替代。</p>
<h1 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点?"></a>索引的优缺点?</h1><p>1、优点：</p>
<p>a）可以保证数据库表中每一行的数据的唯一性</p>
<p>b）可以大大加快数据的索引速度</p>
<p>c）加速表与表之间的连接，物别是在实现数据的参考完事性方面特别有意义</p>
<p>d）在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间</p>
<p>f）通过使用索引，可以在时间查询的过程中，使用优化隐藏器，提高系统的性能</p>
<p>2、 缺点：</p>
<p>a)  创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</p>
<p>b)  索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间，如果需要建立聚簇索引，那么需要占用的空间会更大</p>
<p>c)  以表中的数据进行增、删、改的时候，索引也要动态的维护，这就降低了整数的维护速度</p>
<p>d)  建立索引的原则</p>
<p>e)  在经常需要搜索的列上，可以加快搜索的速度</p>
<p>f)  在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构</p>
<p>g)  在经常用在连接的列上，这些列主要是一外键，可以加快连接的速度</p>
<p>h)  在经经常需要根据范围进行搜索的列上创建索引，国为索引已经排序，其指定的范围是连续的</p>
<p>i)  在经常需要排序的列上，国为索引已经排序，这样井底可以利用索引的排序，加快排序井底时间</p>
<p>j)  在经常使用在where子句中的列上，加快条件的判断速度</p>
<h1 id="MyISAM和InnoDB的区别"><a href="#MyISAM和InnoDB的区别" class="headerlink" title="MyISAM和InnoDB的区别"></a>MyISAM和InnoDB的区别</h1><p>　　主要有以下区别：</p>
<p>　　（1）MySQL默认采用的是MyISAM。</p>
<p>　　（2）MyISAM不支持事务，而InnoDB支持。InnoDB的AUTOCOMMIT默认是打开的，即每条SQL语句会默认被封装成一个事务，自动提交，这样会影响速度，所以最好是把多条SQL语句显示放在begin和commit之间，组成一个事务去提交。</p>
<p>　　（3）InnoDB支持数据行锁定，MyISAM不支持行锁定，只支持锁定整个表。即MyISAM同一个表上的读锁和写锁是互斥的，MyISAM并发读写时如果等待队列中既有读请求又有写请求，默认写请求的优先级高，即使读请求先到，所以MyISAM不适合于有大量查询和修改并存的情况，那样查询进程会长时间阻塞。因为MyISAM是锁表，所以某项读操作比较耗时会使其他写进程饿死。</p>
<p>　　（4）InnoDB支持外键，MyISAM不支持。</p>
<p>　　（5）InnoDB的主键范围更大，最大是MyISAM的2倍。</p>
<p>　　（6）InnoDB不支持全文索引，而MyISAM支持。全文索引是指对char、varchar和text中的每个词（停用词除外）建立倒排序索引。MyISAM的全文索引其实没啥用，因为，它不支持中文分词，必须由使用者分词后加入空格再写到数据表里，而且少于4个汉字的词会和停用词一样被忽略掉。</p>
<p>　　（7）MyISAM支持GIS数据，InnoDB不支持。即MyISAM支持以下空间数据对象：Point,Line,Polygon,Surface等。</p>
<p>　　（8）没有where的count(<em>)使用MyISAM要比InnoDB快得多。因为MyISAM内置了一个计数器，count(</em>)时它直接从计数器中读，而InnoDB必须扫描全表。</p>
<p>　　　　所以在InnoDB上执行count(*)时一般要伴随where，且where中要包含主键以外的索引列。</p>
<p>　　　　为什么这里特别强调“主键以外”？因为InnoDB中primary index是和raw data存放在一起的，而secondary index则是单独存放，然后有个指针指向primary key。</p>
<p>　　　　所以只是count(*)的话使用secondary index扫描更快，而primary key则主要在扫描索引同时要返回raw data时的作用较大。</p>
<h1 id="mysql的行级锁和表级锁的区别？"><a href="#mysql的行级锁和表级锁的区别？" class="headerlink" title="mysql的行级锁和表级锁的区别？"></a>mysql的行级锁和表级锁的区别？</h1><ol>
<li>表锁：不会出现死锁，发生锁冲突几率高，并发低。MySQL的表级锁有两种模式：</li>
</ol>
<p>　　　　表共享读锁，表独占写锁。</p>
<ol>
<li>行锁：会出现死锁，发生锁冲突几率低，并发高。</li>
</ol>
<p>　　　   如果在一条select语句后加上for update，则查询到的数据会被加上一条排它锁，其它事务可以读取，但不能进行更新和插入操作</p>
<ol start="3">
<li>注意：对MyISAM表的读操作，不会阻塞其它进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。</li>
</ol>
<p>　　　   对MyISAM表的写操作，会阻塞其它进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。</p>
<ol start="4">
<li>注意：尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁</li>
</ol>
<p>　　　  合理设计索引，尽量缩小锁的范围</p>
<p>　　　  尽可能减少索引条件，避免间隙锁</p>
<p>　　　  尽量控制事务大小，减少锁定资源量和时间长度</p>
<ol start="5">
<li>lock table 表名 write 加写锁，lock table 表名 read 加读锁</li>
</ol>
<h1 id="mysql的优化方式？"><a href="#mysql的优化方式？" class="headerlink" title="mysql的优化方式？"></a>mysql的优化方式？</h1><ol>
<li>选择最合适的字段属性</li>
<li>尽量把字段设置为NOT NULL</li>
<li>使用连接(JOIN)来代替子查询(Sub-Queries)</li>
<li>使用联合(UNION)来代替手动创建的临时表</li>
<li>事务</li>
<li>使用外键</li>
<li>锁定表</li>
<li>使用索引</li>
<li>优化查询语句:</li>
</ol>
<p>　　　　A不使用子查询</p>
<p>　　　　B避免函数索引（尽量不要使用函数）</p>
<p>　　　　C用in来替换or</p>
<p>　　　　D LIKE双百分号无法使用到索引</p>
<p>　　　　E读取适当的记录LIMIT M,N</p>
<p>　　　　F避免数据类型不一致</p>
<p>　　　　G分组统计可以禁止排序</p>
<p>　　　　H避免随机取记录</p>
<p>　　　　I禁止不必要的ORDER BY排序</p>
<p>　　　　J批量INSERT插入</p>
<h1 id="哪些情况下索引会失效？"><a href="#哪些情况下索引会失效？" class="headerlink" title="哪些情况下索引会失效？"></a>哪些情况下索引会失效？</h1><ol>
<li>字段类型不匹配导致的索引失效</li>
<li>被索引字段使用了表达式计算</li>
<li>被索引字段使用了内置函数</li>
<li>like 使用了 %X 模糊匹配</li>
<li>索引字段不是联合索引字段的最左字段</li>
<li>or 分割的条件，如果 or 左边的条件存在索引，而右边的条件没有索引，不走索引</li>
<li>in、not in 可能会导致索引失效</li>
</ol>
<h1 id="事务的隔离级别有哪些？"><a href="#事务的隔离级别有哪些？" class="headerlink" title="事务的隔离级别有哪些？"></a>事务的隔离级别有哪些？</h1><p>　　数据库事务的隔离级别有4个，由低到高依次为Read uncommitted(读未提交)、Read committed（读已提交）、Repeatable read（可重复读取）、Serializable（序列化），后三个级别可以逐个解决脏读、不可重复读、幻象读这几类问题。</p>
<p>　　　   1、Read uncommitted(读未提交）：</p>
<p>　　　　　    如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。这样就避免了更新丢失，却可能出现脏读。也就是说事务B读取到了事务A未提交的数据。</p>
<p>　　　　2、Read committed（读已提交）：</p>
<p>　　　　　　读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。该隔离级别避免了脏读，但是却可能出现不可重复读。事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时,数据已经发生了改变。</p>
<p>　　　　3、Repeatable read（可重复读取）：</p>
<p>　　　　　　可重复读是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，即使第二个事务对数据进行修改，第一个事务两次读到的的数据是一样的。这样就发生了在一个事务内两次读到的数据是一样的，因此称为是可重复读。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。这样避免了不可重复读取和脏读，但是有时可能出现幻象读。（读取数据的事务）这可以通过“共享读锁”和“排他写锁”实现。（这是数据库的默认隔离级别）</p>
<p>　　　　4、Serializable（序列化）：</p>
<p>　　　　　　提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。如果仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。序列化是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed。它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。</p>
<h1 id="MySQL查询的生命周期包括？"><a href="#MySQL查询的生命周期包括？" class="headerlink" title="MySQL查询的生命周期包括？"></a>MySQL查询的生命周期包括？</h1><p>创建连接、解析SQL、检查权限、优化查询、执行查询(与存储引擎进行交互)、返回结果给应用程序或客户端</p>
<h1 id="数据库三大范式是什么？"><a href="#数据库三大范式是什么？" class="headerlink" title="数据库三大范式是什么？"></a>数据库三大范式是什么？</h1><p>第一范式：</p>
<p>　　1NF是对属性的原子性，要求属性具有原子性，不可再分解；</p>
<p>　　第二范式：</p>
<p>　　2NF是对记录的唯一性，要求记录有唯一标识，即实体的唯一性，即不存在部分依赖；</p>
<p>　　第三范式：</p>
<p>　　3NF是对字段的冗余性，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存</p>
<h1 id="msyql的存储引擎，以及各自的区别，myisam和innodb区别"><a href="#msyql的存储引擎，以及各自的区别，myisam和innodb区别" class="headerlink" title="msyql的存储引擎，以及各自的区别，myisam和innodb区别"></a>msyql的存储引擎，以及各自的区别，myisam和innodb区别</h1><p>InnoDB是MySQL默认的存储引擎。</p>
<p>2.只有 InnoDB 支持事务，MyISAM不支持事务。</p>
<p>3.MyISAM不支持行级锁和外键， InnoDB支持。</p>
<p>4.InnoDB表的大小更加的大，用MyISAM可省很多的硬盘空间。</p>
<p>5.InnoDB 引擎的索引和文件是存放在一起的,找到索引就可以找到数据,是聚簇式设计。</p>
<p>6.MyISAM 引擎采用的是非聚簇式(即使是主键)设计,索引文件和数据文件不在同一个文件中。</p>
<h1 id="mysql索引有哪些，你是如何做索引的？"><a href="#mysql索引有哪些，你是如何做索引的？" class="headerlink" title="mysql索引有哪些，你是如何做索引的？"></a>mysql索引有哪些，你是如何做索引的？</h1><p>从数据结构角度</p>
<p>(1)、B+树索引(O(log(n)))：关于B+树索引，可以参考 MySQL索引背后的数据结构及算法原理</p>
<p>(2)、hash索引：</p>
<p>从物理存储角度</p>
<p>(1)、聚集索引（clustered index）</p>
<p>(2)、非聚集索引（non-clustered index）</p>
<p>从逻辑角度</p>
<p>(1)、主键索引：主键索引是一种特殊的唯一索引，不允许有空值</p>
<p>(2)、普通索引或者单列索引</p>
<p>(3)、多列索引（复合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合</p>
<p>(4)、唯一索引或者非唯一索引</p>
<p>(5)、空间索引：空间索引是对空间数据类型的字段建立的索引</p>
<h1 id="mysql索引优化"><a href="#mysql索引优化" class="headerlink" title="mysql索引优化"></a>mysql索引优化</h1><p>列越小越快</p>
<p>枚举类型替代varchar</p>
<p>避免null值</p>
<p>固定长度的表比动态的快（避免text等不定长字段）</p>
<p>垂直分表（降低表的复杂度，不常用的字段分离出来单独存储）</p>
<p>合理设置索引</p>
<p>分表，分布式（主从）</p>
<h1 id="mysql的事务特性"><a href="#mysql的事务特性" class="headerlink" title="mysql的事务特性"></a>mysql的事务特性</h1><p>原子性：事务是一个不可分割的工作单位，要么同时成功，要么同时失败。例：当两个人发起转账业务时，如果A转账发起，而B因为一些原因不能成功接受，事务最终将不会提交，则A和B的请求最终不会成功。</p>
<p>持久性：一旦事务提交，他对数据库的改变就是永久的。注：只要提交了事务，将会对数据库的数据进行永久性刷新。</p>
<p>隔离性：多个事务之间相互隔离的，互不干扰</p>
<p>一致性：事务执行接收之后，数据库完整性不被破坏</p>
<p>注意：只有当前三条性质都满足了，才能保证事务的一致性</p>
<h1 id="mysql的读写分离"><a href="#mysql的读写分离" class="headerlink" title="mysql的读写分离"></a>mysql的读写分离</h1><p>读写分离解决的是，数据库的写操作，影响了查询的效率，适用于读远大于写的场景。读写分离的实现基础是主从复制，主数据库利用主从复制将自身数据的改变同步到从数据库集群中，然后主数据库负责处理写操作（当然也可以执行读操作），从数据库负责处理读操作，不能执行写操作。并可以根据压力情况，部署多个从数据库提高读操作的速度，减少主数据库的压力，提高系统总体的性能。</p>
<p>msyql如何分表分库分表<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/shida219/article/details/117981566">https://blog.csdn.net/shida219/article/details/117981566</a></p>
<p>msyql 查询和更新执行过程</p>
<p>msyql悲观和乐观锁<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45433031/article/details/120838045">https://blog.csdn.net/weixin_45433031/article/details/120838045</a></p>
<p>msyql索引回表<br>InnoDB引擎中，非主键索引查找数据时需要先找到主键，再根据主键查找具体行数据，这种现象叫回表查询</p>
<p>索引覆盖，即将查询sql中的字段添加到联合索引里面，只要保证查询语句里面的字段都在索引文件中，就无需进行回表查询；</p>
<h1 id="msyql索引失效"><a href="#msyql索引失效" class="headerlink" title="msyql索引失效"></a>msyql索引失效</h1><p>1、like查询以“%”开头；</p>
<p>2、or语句前后没有同时使用索引；</p>
<p>3、组合索引中不是使用第一列索引；</p>
<p>4、在索引列上使用“IS NULL”或“IS NOT NULL”操作；</p>
<p>5、在索引字段上使用“not”，“&lt;&gt;”，“!&#x3D;”。</p>
<p>6、如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不使用索引</p>
<p>7、当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效。</p>
<h1 id="什么是死锁？什么是脏读？幻读？不可重复读？"><a href="#什么是死锁？什么是脏读？幻读？不可重复读？" class="headerlink" title="什么是死锁？什么是脏读？幻读？不可重复读？"></a>什么是死锁？什么是脏读？幻读？不可重复读？</h1><p>脏读（无效的数据）</p>
<p>a事务把数据改完之后并没有提交，b事务读到这个改完数据之后的事务，</p>
<p>b事务读完之后，a事务又把数据做了一个回滚操作，这种现象叫脏读</p>
<p>不可重复读</p>
<p>a事务把数据读完拿去用了，b事务刚好直接把数据给改了，并且提交了，</p>
<p>a事务会发现之前读的数据不准确了</p>
<p>幻读现象</p>
<p>是不可重复读的一种特殊现象，</p>
<p>举例：假设一张表一共有10条数据，a事务把id大于3的数据name全部改成了xx，</p>
<p>就在刚刚改完的那一刻，b事务又插入一条数据，a事务改完之后，会发现有一条数据没有修改成功</p>
<p>MySQL数据库cpu飙升到100%的话怎么处理？<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/t707584896/article/details/129971047">https://blog.csdn.net/t707584896/article/details/129971047</a></p>
<h1 id="MySQL主从复制解决了哪些问题？"><a href="#MySQL主从复制解决了哪些问题？" class="headerlink" title="MySQL主从复制解决了哪些问题？"></a>MySQL主从复制解决了哪些问题？</h1><p>1、数据的备份（很多企业用从库来做专业数据库备份服务器）</p>
<p>2、读写分离，这样减少主库的压力，支持更大的并发，主写从读。还可以单独使用一个从库来做为企业内部人员查询数据使用的服务器，这样更有利于减少线上服务器的访问压力。</p>
<p>3、高可用，主从复制+故障切换，实现线上业务不宕机运行。</p>
<p>binlog和redo log有什么区别？<br>1.Redo Log是属于InnoDB引擎功能，Binlog是属于MySQL Server自带功能，并且是以二进制文件记录。</p>
<p>2.Redo Log属于物理日志，记录该数据页更新状态内容，Binlog是逻辑日志，记录更新过程。</p>
<p>3.Redo Log日志是循环写，日志空间大小是固定，Binlog是追加写入，写完一个写下一个，不会覆盖使用。</p>
<p>4.Redo Log作为服务器异常宕机后事务数据自动恢复使用，Binlog可以作为主从复制和数据恢复使用。Binlog没有自动crash-safe能力。</p>
<p>5.由binlog和redo log的概念和区别可知：binlog日志只用于归档，只依靠binlog是没有crash-safe能力的。但只有redo log也不行，因为redo log是InnoDB特有的，且日志上的记录落盘后会被覆盖掉。因此需要binlog和redo log二者同时记录，才能保证当数据库发生宕机重启时，数据不会丢失</p>
<h1 id="慢SQL如何定位呢？"><a href="#慢SQL如何定位呢？" class="headerlink" title="慢SQL如何定位呢？"></a>慢SQL如何定位呢？</h1><p>1.首先确认是否开启了慢查询</p>
<p>2.设置慢查询的时间限制</p>
<p>3.查询慢查询日志可定位具体的慢sql</p>
<p>4.相关sql查询</p>
<p>5.用Explain分析具体的sql语句</p>
<p>id:选择标识符</p>
<p>select_type:表示查询的类型。</p>
<p>table:输出结果集的表</p>
<p>partitions:匹配的分区</p>
<p>type:表示表的连接类型</p>
<p>possible_keys:表示查询时，可能使⽤的索引</p>
<p>key:表示实际使⽤的索引</p>
<p>key_len:索引字段的长度</p>
<p>ref:列与索引的比较</p>
<p>rows:扫描出的行数(估算的行数)</p>
<p>filtered:按表条件过滤的⾏百分比</p>
<p>Extra:执行情况的描述和说明</p>
<h1 id="MySQL单表过亿条数据，如何优化查询速度？"><a href="#MySQL单表过亿条数据，如何优化查询速度？" class="headerlink" title="MySQL单表过亿条数据，如何优化查询速度？"></a>MySQL单表过亿条数据，如何优化查询速度？</h1><p>分库：是为了解决数据库连接资源不足问题，和磁盘IO的性能瓶颈问题。</p>
<p>分表：是为了解决单表数据量太大，sql语句查询数据时，即使走了索引也非常耗时问题。此外还可以解决消耗cpu资源问题。</p>
<p>分库分表：可以解决 数据库连接资源不足、磁盘IO的性能瓶颈、检索数据耗时 和 消耗cpu资源等问题。</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/439988021/answer/2436380280">https://www.zhihu.com/question/439988021/answer/2436380280</a></p>
<h1 id="百亿级数据分表后怎么分页查询？"><a href="#百亿级数据分表后怎么分页查询？" class="headerlink" title="百亿级数据分表后怎么分页查询？"></a>百亿级数据分表后怎么分页查询？</h1><p>分表规则定位具体表，或者双写</p>
<p>最后考虑 离线数仓或者ES查询</p>
<h1 id="int-1-和int（10）区别"><a href="#int-1-和int（10）区别" class="headerlink" title="int(1)和int（10）区别"></a>int(1)和int（10）区别</h1><p>INT(1) 和 INT(10)本身没有区别,但是INT[(M)] 加上ZEROFILL值后,会对值有宽度的设置，不够位数前面自动补0.</p>
<p>MySQL:数据库自增 ID 用完了会咋样？<br>把主键类型改为 bigint，也就是 8 个字节。这样能存储的最大数据量就是 2^64</p>
<p>PS：单表 21 亿的数据量显然不现实，一般来说数据量达到 500 万就该分表了</p>
<h1 id="数据库主从复制，读写分离"><a href="#数据库主从复制，读写分离" class="headerlink" title="数据库主从复制，读写分离"></a>数据库主从复制，读写分离</h1><ul>
<li>什么是主从复制<br>主从复制，是用来建立一个和主数据库完全一样的数据库环境，称为从数据库；</li>
<li>主从复制的原理：<br>1.数据库有个bin-log二进制文件，记录了所有的sql语句。<br>2.只需要把主数据库的bin-log文件中的sql语句复制。<br>3.让其从数据的relay-log重做日志文件中在执行一次这些sql语句即可。</li>
<li>主从复制的作用<br>1.做数据的热备份，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。<br>2.架构的扩展。业务量越来越大，I&#x2F;O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I&#x2F;O访问频率，提高单机的I&#x2F;O性能<br>3.主从复制是读写分离的基础，使数据库能制成更大 的并发。例如子报表中，由于部署报表的sql语句十分慢，导致锁表，影响前台的服务。如果前台服务使用master，报表使用slave，那么报表sql将不会造成前台所，保证了前台的访问速度。</li>
<li>主从复制的几种方式：<br>1.同步复制：所谓的同步复制，意思是master的变化，必须等待slave-1,slave-2,…,slave-n完成后才能返回。<br>2.异步复制：如同AJAX请求一样。master只需要完成自己的数据库操作即可。至于slaves是否收到二进制日志，是否完成操作，不用关心。MYSQL的默认设置。<br>3.半同步复制：master只保证slaves中的一个操作成功，就返回，其他slave不管。<br>这个功能，是由google为MYSQL引入的。</li>
<li>关于读写分离<br>在完成主从复制时，由于slave是需要同步master的。所以对于insert&#x2F;delete&#x2F;update这些更新数据库的操作，应该在master中完成。而select的查询操作，则落下到slave中。</li>
</ul>
<h1 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h1><p><strong>什么是索引</strong><br>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。（摘自百度百科）</p>
<p><strong>索引类型</strong><br>1.FULLTEXT 全文索引<br>    全文索引，仅MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。<br>2.HASH 哈希索引<br>    HASH索引的唯一性及类似键值对的形式十分适合作为索引，HASH索引可以一次定位，不需要像树形索引那样逐层参照，因此具有极高的效率。但是这种高效是有条件的。即只在“&#x3D;”和“in”条件下高效，对于范围查询，排序及组合索引仍然效率不高。<br>3.BTREE 树形索引<br>    BTREE所以是一种将索引按一定算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，一次遍历node，获取leaf。这是MySQL中默认也是最常用的索引类型。<br>4.RTREE<br>    RTREE在MySQL中很少使用，仅支持geometry数据类型，支持该存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。相对于BTREE，RTREE的优势在于范围查找。</p>
<p><strong>索引种类</strong><br>普通索引：仅加速查询<br>唯一索引：加速查询+列值唯一（可以有null）<br>主键索引：加速查询+列值唯一（不可以有null）+表中只有一个<br>组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并<br>全文索引：对文本内容进行分词，进行搜索<br>外键索引：与主键索引形成联系，保证数据的完整性。</p>
<p><strong>索引使用的注意事项</strong><br>1.符合索引遵循前缀原则<br>2.like查询%不能再前，否则索引失效。如有需要，使用全文索引<br>3.column is null可以使用索引<br>4.如果MySQL估计使用索引比全表扫描慢，则放弃使用索引<br>5.如果or前的条件中列有索引，后面的没有，索引不会生效。<br>6.列类型是字符串，查询时，一定要给值加引号，否则索引失效。<br>7.确定order by 和 group by 中只有一个表的列，这样才能使用索引</p>
<h1 id="innoDB，MyISAM-的区别"><a href="#innoDB，MyISAM-的区别" class="headerlink" title="innoDB，MyISAM 的区别"></a>innoDB，MyISAM 的区别</h1><p>MyISAM:<br>不支持事务；<br>数据存储在磁盘，可被压缩，存储空间较小；<br>只支持表级锁；<br>支持(FULLTEXT类型的)全文索引。<br>保存有表的总行数，如果select count(*) from table，会直接取出该值；<br>如果执行大量的SELECT，MyISAM是更好的选择；<br>不支持外键；</p>
<p>InnoDB：<br>支持事务；<br>存储在共享空间，需要更多的内存和存储；<br>具有事务、回滚和崩溃修复能力；<br>只支持行级锁；<br>不支持(FULLTEXT类型的)全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好；<br>支持外键；<br>如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。</p>
<h1 id="MyISAM和InnoDB两者的应用场景："><a href="#MyISAM和InnoDB两者的应用场景：" class="headerlink" title="MyISAM和InnoDB两者的应用场景："></a>MyISAM和InnoDB两者的应用场景：</h1><ol>
<li>MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。</li>
<li>InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。</li>
</ol>
<h1 id="分析-MySQL-查询慢的原因"><a href="#分析-MySQL-查询慢的原因" class="headerlink" title="分析 MySQL 查询慢的原因"></a>分析 MySQL 查询慢的原因</h1><p>.查看慢查询日志<br>.通过pt-query-digest工具分析<br>.设置set profiling &#x3D; 1;开启服务，执行show profile。查看所有语句会监测消耗时间存到临时表<br>.找到消耗时间大的ID，执行show profile for query 临时表ID<br>.使用show status，show processlist 等命令查看<br>.使用explain分析单条SQL语句 </p>
<h1 id="三大范式是什么？"><a href="#三大范式是什么？" class="headerlink" title="三大范式是什么？"></a>三大范式是什么？</h1><ul>
<li>第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；</li>
<li>第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；</li>
<li>第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；</li>
</ul>
<h1 id="怎么区分三大范式？"><a href="#怎么区分三大范式？" class="headerlink" title="怎么区分三大范式？"></a>怎么区分三大范式？</h1><p>第一范式和第二范式在于有没有分出两张表，</p>
<p>第二范式是说一张表中包含了所种不同的实体属性，那么要必须分成多张表， </p>
<p>第三范式是要求已经分成了多张表，那么一张表中只能有另一张表中的id（主键），而不能有其他的任何信息（其他的信息一律用主键在另一表查询）。</p>
<h1 id="数据库五大约束是什么？"><a href="#数据库五大约束是什么？" class="headerlink" title="数据库五大约束是什么？"></a>数据库五大约束是什么？</h1><p>1.primary KEY:设置主键约束；<br>2.UNIQUE：设置唯一性约束，不能有重复值；<br>3.DEFAULT 默认值约束，height DOUBLE(3,2)DEFAULT 1.2 height不输入是默认为1,2<br>4.NOT NULL：设置非空约束，该字段不能为空；<br>5.FOREIGN key :设置外键约束。</p>
<h1 id="主键是什么，怎么设置主键？"><a href="#主键是什么，怎么设置主键？" class="headerlink" title="主键是什么，怎么设置主键？"></a>主键是什么，怎么设置主键？</h1><p>主键默认非空，默认唯一性约束，只有主键才能设置自动增长，自动增长一定是主键，主键不一定自动增长；</p>
<p>在定义列时设置：ID INT PRIMARY KEY<br>在列定义完之后设置：primary KEY（id）</p>
<h1 id="数据库的外键是什么？"><a href="#数据库的外键是什么？" class="headerlink" title="数据库的外键是什么？"></a>数据库的外键是什么？</h1><p>只有INNODB的数据库引擎支持外键。<br>不见已使用基于mysql的物理外键，这样可能会有超出预期的后果。推荐使用逻辑外键，就是自己做表设计，根据代码逻辑设定的外键，自行实现相关的数据操作。</p>
<h1 id="innodb和myisam有什么区别？"><a href="#innodb和myisam有什么区别？" class="headerlink" title="innodb和myisam有什么区别？"></a>innodb和myisam有什么区别？</h1><ul>
<li>InnoDB支持事务，而MyISAM不支持事物，崩溃后无法安全恢复，表锁非常影响性能</li>
<li>InnoDB支持行级锁，而MyISAM支持表级锁</li>
<li>InnoDB支持MVCC，实现了四个标准的隔离级别 而MyISAM不支持</li>
<li>InnoDB 表是基于聚族索引建立的，聚族索引对主键查询有很高的性能</li>
<li>InnoDB支持外键，而MyISAM不支持</li>
<li>MyISAM 存储引擎已经有了20年的历史，在1995年时，MyISAM 是 MySQL 唯一的存储引擎，服务了20多年，即将退居二线。随着mysql5.7，8版本的提升，myisam优点已经逐渐被 InnoDB 实现了。比如全文索引，表空间优化，临时表优化，高效的count(*)</li>
</ul>
<h1 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h1><p>索引是一种数据结构,可以帮助我们快速的进行数据的查找.</p>
<h1 id="索引是个什么样的数据结构呢"><a href="#索引是个什么样的数据结构呢" class="headerlink" title="索引是个什么样的数据结构呢?"></a>索引是个什么样的数据结构呢?</h1><p>索引的数据结构和具体存储引擎的实现有关, 在MySQL中使用较多的索引有Hash索引,B+树索引等,而我们经常使用的InnoDB存储引擎的默认索引实现为:B+树索引.</p>
<h1 id="innodb索引的实现原理是什么？"><a href="#innodb索引的实现原理是什么？" class="headerlink" title="innodb索引的实现原理是什么？"></a>innodb索引的实现原理是什么？</h1><p>InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用”where id &#x3D; 14”这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。</p>
<h1 id="btree和hash类型的索引有什么不同？"><a href="#btree和hash类型的索引有什么不同？" class="headerlink" title="btree和hash类型的索引有什么不同？"></a>btree和hash类型的索引有什么不同？</h1><p>首先要知道Hash索引和B+树索引的底层实现原理:</p>
<p>hash索引底层就是hash表,进行查找时,调用一次hash函数就可以获取到相应的键值,之后进行回表查询获得实际数据.B+树底层实现是多路平衡查找树.对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值,然后根据查询判断是否需要回表查询数据.</p>
<p>那么可以看出他们有以下的不同:</p>
<ul>
<li>hash索引进行等值查询更快(一般情况下),但是却无法进行范围查询.</li>
</ul>
<p>因为在hash索引中经过hash函数建立索引之后,索引的顺序与原顺序无法保持一致,不能支持范围查询.而B+树的的所有节点皆遵循(左节点小于父节点,右节点大于父节点,多叉树也类似),天然支持范围.</p>
<ul>
<li>hash索引不支持使用索引进行排序,原理同上.</li>
<li>hash索引不支持模糊查询以及多列索引的最左前缀匹配.原理也是因为hash函数的不可预测.<strong>AAAA</strong>和<strong>AAAAB</strong>的索引没有相关性.</li>
<li>hash索引任何时候都避免不了回表查询数据,而B+树在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询.</li>
<li>hash索引虽然在等值查询上较快,但是不稳定.性能不可预测,当某个键值存在大量重复的时候,发生hash碰撞,此时效率可能极差.而B+树的查询效率比较稳定,对于所有的查询都是从根节点到叶子节点,且树的高度较低.</li>
</ul>
<p>因此,在大多数情况下,直接选择B+树索引可以获得稳定且较好的查询速度.而不需要使用hash索引.</p>
<h1 id="什么是覆盖索引？"><a href="#什么是覆盖索引？" class="headerlink" title="什么是覆盖索引？"></a>什么是覆盖索引？</h1><p>简单的说，select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。</p>
<p>覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引不存储索引列的值，所以mysql<strong>只能用B-tree索引</strong>做覆盖索引。</p>
<h1 id="B-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，什么是聚簇索引"><a href="#B-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，什么是聚簇索引" class="headerlink" title="B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，什么是聚簇索引?"></a>B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，什么是聚簇索引?</h1><p>在B+树的索引中,叶子节点可能存储了当前的key值,也可能存储了当前的key值以及整行的数据,这就是聚簇索引和非聚簇索引. 在InnoDB中,只有主键索引是聚簇索引,如果没有主键,则挑选一个唯一键建立聚簇索引.如果没有唯一键,则隐式的生成一个键来建立聚簇索引.</p>
<p>当查询使用聚簇索引时,在对应的叶子节点,可以获取到整行数据,因此不用再次进行回表查询.</p>
<h1 id="在建立索引的时候-都有哪些需要考虑的因素呢"><a href="#在建立索引的时候-都有哪些需要考虑的因素呢" class="headerlink" title="在建立索引的时候,都有哪些需要考虑的因素呢?"></a>在建立索引的时候,都有哪些需要考虑的因素呢?</h1><p>建立索引的时候一般要考虑到字段的使用频率,经常作为条件进行查询的字段比较适合.如果需要建立联合索引的话,还需要考虑联合索引中的顺序.此外也要考虑其他方面,比如防止过多的所有对表造成太大的压力.这些都和实际的表结构以及查询方式有关</p>
<h1 id="联合索引-多列索引的注意事项是什么？"><a href="#联合索引-多列索引的注意事项是什么？" class="headerlink" title="联合索引&#x2F;多列索引的注意事项是什么？"></a>联合索引&#x2F;多列索引的注意事项是什么？</h1><p>MySQL可以使用多个字段同时建立一个索引,叫做联合索引.在联合索引中,如果想要命中索引,需要按照建立索引时的字段顺序挨个使用,否则无法命中索引.</p>
<p>具体原因为:</p>
<p>MySQL使用索引时需要索引有序,假设现在建立了”name,age,school”的联合索引,那么索引的排序为: 先按照name排序,如果name相同,则按照age排序,如果age的值也相等,则按照school进行排序.</p>
<p>当进行查询时,此时索引仅仅按照name严格有序,因此必须首先使用name字段进行等值查询,之后对于匹配到的列而言,其按照age字段严格有序,此时可以使用age字段用做索引查找,,,以此类推.因此在建立联合索引的时候应该注意索引列的顺序,一般情况下,将查询需求频繁或者字段选择性高的列放在前面.此外可以根据特例的查询或者表结构进行单独的调整.</p>
<h1 id="导致索引失效的原因有哪些？"><a href="#导致索引失效的原因有哪些？" class="headerlink" title="导致索引失效的原因有哪些？"></a>导致索引失效的原因有哪些？</h1><ul>
<li>列参与了数学运算或者函数；</li>
<li>如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)；</li>
<li>对于多列索引，不符合最左匹配的命中规则；</li>
<li>like查询是以%开头；</li>
<li>如果直接查比用索引快，那么数据库会自动选择最优方式，不用索引；</li>
<li>in 和 not in 也要慎用，否则会导致全表扫描。</li>
</ul>
<h1 id="主键使用自增ID还是UUID"><a href="#主键使用自增ID还是UUID" class="headerlink" title="主键使用自增ID还是UUID?"></a>主键使用自增ID还是UUID?</h1><p>推荐使用自增ID,不要使用UUID.</p>
<p>因为在InnoDB存储引擎中,主键索引是作为聚簇索引存在的,也就是说,主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序),如果主键索引是自增ID,那么只需要不断向后排列即可,如果是UUID,由于到来的ID与原来的大小不确定,会造成非常多的数据插入,数据移动,然后导致产生很多的内存碎片,进而造成插入性能的下降.</p>
<p>总之,在数据量大一些的情况下,用自增主键性能会好一些.</p>
<h1 id="字段为什么要求定义为not-null"><a href="#字段为什么要求定义为not-null" class="headerlink" title="字段为什么要求定义为not null?"></a>字段为什么要求定义为not null?</h1><p>MySQL官网这样介绍:</p>
<blockquote>
<p>NULL columns require additional space in the rowto record whether their values are NULL. For MyISAM tables, each NULL columntakes one bit extra, rounded up to the nearest byte.</p>
</blockquote>
<p>null值会占用更多的字节,且会在程序中造成很多与预期不符的情况.</p>
<h1 id="drop、delete与truncate分别在什么场景之下使用？"><a href="#drop、delete与truncate分别在什么场景之下使用？" class="headerlink" title="drop、delete与truncate分别在什么场景之下使用？"></a>drop、delete与truncate分别在什么场景之下使用？</h1><p>我们来对比一下他们的区别：</p>
<p>drop table</p>
<ul>
<li>1)属于DDL</li>
<li>2)不可回滚</li>
<li>3)不可带where</li>
<li>4)表内容和结构删除</li>
<li>5)删除速度快</li>
</ul>
<p>truncate table</p>
<ul>
<li>1)属于DDL</li>
<li>2)不可回滚</li>
<li>3)不可带where</li>
<li>4)表内容删除</li>
<li>5)删除速度快</li>
</ul>
<p>delete from</p>
<ul>
<li>1)属于DML</li>
<li>2)可回滚</li>
<li>3)可带where</li>
<li>4)表结构在，表内容要看where执行的情况</li>
<li>5)删除速度慢,需要逐行删除</li>
</ul>
<p>总结：<br><strong>不再需要一张表的时候，用drop</strong><br><strong>想删除部分数据行时候，用delete，并且带上where子句</strong><br><strong>保留表而删除所有数据的时候用truncate</strong></p>
<h1 id="MySQL中的varchar和char有什么区别"><a href="#MySQL中的varchar和char有什么区别" class="headerlink" title="MySQL中的varchar和char有什么区别?"></a>MySQL中的varchar和char有什么区别?</h1><ol>
<li>char的长度是不可变的，而varchar的长度是可变的 。</li>
<li>定义一个char[10]和varchar[10],如果存进去的是‘abcd’,那么char所占的长度依然为10，除了字符‘abcd’外，后面跟六个空格，而varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的，</li>
<li>char的存取速度比varchar要快得多，因为其长度固定，方便程序的存储与查找；但是char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率，而varchar是以空间效率为首位的。</li>
<li>char的存储方式是，对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节；而varchar的存储方式是，对每个英文字符占用2个字节，汉字也占用2个字节，两者的存储数据都非unicode的字符数据。</li>
<li>char适合存储长度固定的数据，varchar适合存储长度不固定的。</li>
</ol>
<h1 id="varchar-10-和int-10-代表什么含义"><a href="#varchar-10-和int-10-代表什么含义" class="headerlink" title="varchar(10)和int(10)代表什么含义?"></a>varchar(10)和int(10)代表什么含义?</h1><p>varchar的10代表了申请的空间长度,也是可以存储的数据的最大长度,而int的10只是代表了展示的长度,不足10位以0填充.也就是说,int(1)和int(10)所能存储的数字大小以及占用的空间都是相同的,只是在展示时按照长度展示.</p>
<h1 id="超大分页怎么处理"><a href="#超大分页怎么处理" class="headerlink" title="超大分页怎么处理?"></a>超大分页怎么处理?</h1><p>超大的分页一般从两个方向上来解决.</p>
<ul>
<li>数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于<code>select * from table where age &gt; 20 limit 1000000,10</code>这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为<code>select * from table where id in (select id from table where age &gt; 20 limit 1000000,10)</code>.这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以<code>select * from table where id &gt; 1000000 limit 10</code>,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.</li>
<li>从需求的角度减少这种请求….主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.</li>
</ul>
<p>解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可.</p>
<p>在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.</p>
<h1 id="关心过业务系统里面的sql耗时吗-统计过慢查询吗-对慢查询都怎么优化过"><a href="#关心过业务系统里面的sql耗时吗-统计过慢查询吗-对慢查询都怎么优化过" class="headerlink" title="关心过业务系统里面的sql耗时吗?统计过慢查询吗?对慢查询都怎么优化过?"></a>关心过业务系统里面的sql耗时吗?统计过慢查询吗?对慢查询都怎么优化过?</h1><p>在业务系统中,除了使用主键进行的查询,其他的我都会在测试库上测试其耗时,慢查询的统计主要由运维在做,会定期将业务中的慢查询反馈给我们.</p>
<p>慢查询的优化首先要搞明白慢的原因是什么? 是查询条件没有命中索引?是load了不需要的数据列?还是数据量太大?</p>
<p>所以优化也是针对这三个方向来的,</p>
<ul>
<li>首先分析语句,看看是否load了额外的数据,可能是查询了多余的行并且抛弃掉了,可能是加载了许多结果中并不需要的列,对语句进行分析以及重写.</li>
<li>分析语句的执行计划,然后获得其使用索引的情况,之后修改语句或者修改索引,使得语句可以尽可能的命中索引.</li>
<li>如果对语句的优化已经无法进行,可以考虑表中的数据量是否太大,如果是的话可以进行横向或者纵向的分表.</li>
</ul>
<h1 id="上面提到横向分表和纵向分表-可以分别举一个适合他们的例子吗"><a href="#上面提到横向分表和纵向分表-可以分别举一个适合他们的例子吗" class="headerlink" title="上面提到横向分表和纵向分表,可以分别举一个适合他们的例子吗?"></a>上面提到横向分表和纵向分表,可以分别举一个适合他们的例子吗?</h1><p>横向分表是按行分表，假设我们有一张用户表，主键是自增ID且同时是用户的ID.数据量较大,有1亿多条，那么此时放在一张表里的查询效果就不太理想。我们可以根据主键ID进行分表，无论是按尾号分，或者按ID的区间分都是可以的，假设按照尾号0-99分为100个表，那么每张表中的数据就仅有100w，这时的查询效率无疑是可以满足要求的。</p>
<p>纵向分表是按列分表。假设我们现在有一张文章表，包含字段<code>id-摘要-内容</code>，而系统中的展示形式是刷新出一个列表。列表中仅包含标题和摘要，当用户点击某篇文章进入详情时才需要正文内容。此时，如果数据量大,将内容这个很大且不经常使用的列放在一起会拖慢原表的查询速度，我们可以将上面的表分为两张。<code>id-摘要</code>,<code>id-内容</code>.当用户点击详情，那主键再来取一次内容即可。而增加的存储量只是很小的主键字段.代价很小。</p>
<p>当然,分表其实和业务的关联度很高。在分表之前一定要做好调研以及benchmark.不要按照自己的猜想盲目操作、</p>
<h1 id="LEFT-JOIN-、RIGHT-JOIN、INNER-JOIN-区别？"><a href="#LEFT-JOIN-、RIGHT-JOIN、INNER-JOIN-区别？" class="headerlink" title="LEFT JOIN 、RIGHT JOIN、INNER JOIN 区别？"></a>LEFT JOIN 、RIGHT JOIN、INNER JOIN 区别？</h1><ul>
<li>LEFT JOIN(左连接)：获取左表所有记录，即使右表没有对应匹配的记录</li>
<li>RIGHT JOIN(右连接)： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录</li>
<li>INNER JOIN(内连接)：获取两个表中字段匹配关系的记录</li>
</ul>
<h1 id="UNION、UNION-ALL区别？"><a href="#UNION、UNION-ALL区别？" class="headerlink" title="UNION、UNION ALL区别？"></a>UNION、UNION ALL区别？</h1><p>union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；<br>union All：对两个结果集进行并集操作，包括重复行，不进行排序；</p>
<h1 id="你的sql优化常用技巧有哪些？"><a href="#你的sql优化常用技巧有哪些？" class="headerlink" title="你的sql优化常用技巧有哪些？"></a>你的sql优化常用技巧有哪些？</h1><ol>
<li>使用参数化查询：防止SQL注入，预编译SQL命令提高效率</li>
<li>去掉不必要的查询和搜索字段</li>
<li>争取命中索引，或者根据已有的查询情景简历合理的索引</li>
<li>不要使用select *：不要使用select *，以提高查询效率，减少输出的数据量，提高传输速度</li>
<li>尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理</li>
<li>减少访问数据库的次数，业务代码逻辑优化，避免for循环</li>
<li>使用表的别名(Alias)：当在SQL语句中连接多个表时, 减少解析的时间，减少那些由Column歧义引起的语法错误</li>
<li>使用列的别名：当列的名称很长的时候，使用简短的列的别名可以查询结果更清晰，更简洁</li>
<li>状态，类型等字段使用tinyint类型</li>
<li>字段设计not null</li>
<li>索引可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因此索引并非越多越好，合理有效的使用</li>
<li>尽量避免大事务操作，提高系统并发能力</li>
</ol>
<p>已上要点，回答几个应该也就OK了，毕竟面试时间不能总是在聊一道题。</p>
<h1 id="同一个字段，用-int-还是-char-查询效率高"><a href="#同一个字段，用-int-还是-char-查询效率高" class="headerlink" title="同一个字段，用 int 还是 char 查询效率高?"></a>同一个字段，用 int 还是 char 查询效率高?</h1><p>从效率来说，INT效率更高。查询速度也和是否建立索引，字段长度占用的空间大小有关系。</p>
<h1 id="hash索引的实现原理是什么？"><a href="#hash索引的实现原理是什么？" class="headerlink" title="hash索引的实现原理是什么？"></a>hash索引的实现原理是什么？</h1><p>哈希索引的实现基于哈希算法。哈希算法是一种常用的算法，时间复杂度为<code>O(1)</code>。它不仅应用在索引上，各个数据库应用中也都会使用。</p>
<p>InnoDB存储引擎使用哈希算法来对字典进行查找，哈希碰撞采用转链表解决。所以当hash碰撞过多的时候，查询效率就会降低很多。</p>
<h1 id="讲一下你理解的B-树索引是怎么实现的？"><a href="#讲一下你理解的B-树索引是怎么实现的？" class="headerlink" title="讲一下你理解的B+树索引是怎么实现的？"></a>讲一下你理解的B+树索引是怎么实现的？</h1><p>B+树中的B不是代表的二叉（Binary） ，而是代表平衡（Balance），因为B+树是从最早的平衡二叉树演化而来，但是B+树不是一个二叉树。</p>
<p><strong>一步一步的迭代</strong></p>
<ol>
<li>二叉树：相当于一个二分查找，二叉查找能大大提升查询的效率，但是极端情况下，二叉树会变成一个线性链表结构。</li>
<li>平衡二叉树：通过旋转让失衡二叉树恢复平衡。缺点是数据量达到几百万后，树的高度会很恐怖，导致搜索效率不足。其二，存储的数据内容太少，没有很好利用操作系统和磁盘数据交换特性。</li>
<li>多路平衡查找树(Balance Tree，也叫B-tree)：<br>B-Tree是为磁盘等外存储设备设计的一种平衡查找树。B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。<br>B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I&#x2F;O取到内存的数据都发挥了作用，从而提高了查询效率。</li>
<li>B+TREE：<br>B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。</li>
</ol>
<p><strong>B+Tree相对于B-Tree有几点不同：</strong></p>
<ol>
<li><strong>非叶子节点只存储键值信息。</strong></li>
<li><strong>所有叶子节点之间都有一个链指针。</strong></li>
<li><strong>数据记录都存放在叶子节点中</strong></li>
</ol>
<p>可以参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36098284/article/details/80178336">https://blog.csdn.net/qq_36098284/article/details/80178336</a></p>
<p>InnoDB存储引擎就是用B+Tree实现其索引结构。</p>
<h1 id="索引是如何存储在磁盘上的？"><a href="#索引是如何存储在磁盘上的？" class="headerlink" title="索引是如何存储在磁盘上的？"></a>索引是如何存储在磁盘上的？</h1><p>数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。</p>
<p>辅助索引与聚集索引的区别在于：</p>
<p>辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。</p>
<p>当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。</p>
<h1 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h1><p>事务就是为了保证一组数据库操作，要么全部成功，要么全部失败。</p>
<p>事务是在引擎层实现的，也就是说并不是所有引擎都可以使用事务，MyISAM 就不支持事务，这也是为什么会被 InnoDB 取代的原因。</p>
<h1 id="事务的四大特性？"><a href="#事务的四大特性？" class="headerlink" title="事务的四大特性？"></a>事务的四大特性？</h1><p>原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。</p>
<p>**原子性：**一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>
<p>**一致性：**在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p>
<p>**隔离性：**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p>
<p>**持久性：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>
<h1 id="没有隔离级别的话，多事务并发进行会造成什么问题？"><a href="#没有隔离级别的话，多事务并发进行会造成什么问题？" class="headerlink" title="没有隔离级别的话，多事务并发进行会造成什么问题？"></a>没有隔离级别的话，多事务并发进行会造成什么问题？</h1><p>脏读: A事务读取到了B事务未提交的内容,而B事务后面进行了回滚.<br>不可重复读: 当设置A事务只能读取B事务已经提交的部分,会造成在A事务内的两次查询,结果竟然不一样,因为在此期间B事务进行了提交操作.<br>幻读: A事务读取了一个范围的内容,而同时B事务在此期间插入了一条数据.造成”幻觉”.</p>
<h1 id="事务的隔离级别和各自解决的问题是什么？"><a href="#事务的隔离级别和各自解决的问题是什么？" class="headerlink" title="事务的隔离级别和各自解决的问题是什么？"></a>事务的隔离级别和各自解决的问题是什么？</h1><p>隔离性可能会引入脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）等问题，为了解决这些问题就引入了“隔离级别”的概念。</p>
<p>SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable）：</p>
<p>读未提交：一个事务还没提交时，它做的变更就能被别的事务看到。<br>读提交：一个事务提交之后，它做的变更才会被其他事务看到。<br>可重复读： 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。<br>串行化： 顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p>
<h1 id="InnoDB使用的是哪种隔离级别呢"><a href="#InnoDB使用的是哪种隔离级别呢" class="headerlink" title="InnoDB使用的是哪种隔离级别呢?"></a>InnoDB使用的是哪种隔离级别呢?</h1><p>InnoDB默认使用的是可重复读隔离级别. RR</p>
<h1 id="数据库事务的使用的规范有哪些？"><a href="#数据库事务的使用的规范有哪些？" class="headerlink" title="数据库事务的使用的规范有哪些？"></a>数据库事务的使用的规范有哪些？</h1><ol>
<li>控制事务大小，减少锁定的资源量和锁定时间长度。</li>
<li>所有的数据检索都通过索引来完成，从而避免因为无法通过索引加锁而升级为表锁。</li>
<li>减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的数据。</li>
<li>在业务条件允许下，尽量使用较低隔离级别的事务隔离。减少隔离级别带来的附加成本。</li>
<li>合理使用索引，让innodb在索引上面加锁的时候更加准确。</li>
<li>在应用中尽可能做到访问的顺序执行（串行）。</li>
<li>如果容易死锁，就可以考虑使用表锁来减少死锁的概率。</li>
</ol>
<h1 id="InnoDB怎么实现的事务ACID特性？"><a href="#InnoDB怎么实现的事务ACID特性？" class="headerlink" title="InnoDB怎么实现的事务ACID特性？"></a>InnoDB怎么实现的事务ACID特性？</h1><ul>
<li>redo log重做日志用来保证事务的持久性</li>
<li>undo log回滚日志保证事务的原子性</li>
<li>undo log+redo log保证事务的一致性</li>
<li>锁（共享、排他）用来保证事务的隔离性</li>
</ul>
<p>undo log 实现如下两个功能：1.实现事务回滚 2.实现MVCC<br>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。</p>
<p>推荐阅读，加深理解 : <a target="_blank" rel="noopener" href="https://www.cnblogs.com/jianzh5/p/11643151.html">https://www.cnblogs.com/jianzh5/p/11643151.html</a></p>
<h1 id="InnoDB的事务为什么是原子性的？"><a href="#InnoDB的事务为什么是原子性的？" class="headerlink" title="InnoDB的事务为什么是原子性的？"></a>InnoDB的事务为什么是原子性的？</h1><p><strong>InnoDB 引擎使用 undo log（归滚日志）来保证原子性操作</strong>，你对数据库的每一条数据的改动（INSERT、DELETE、UPDATE）都会被记录到 undo log 中，比如以下这些操作：</p>
<ul>
<li>你插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。</li>
<li>你删除了一条记录，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。</li>
<li>你修改了一条记录，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。</li>
</ul>
<p>当事务执行失败或者调用了 rollback 方法时，就会触发回滚事件，利用 undo log 中记录将数据回滚到修改之前的样子。</p>
<h1 id="InnoDB是如何保证隔离性的？"><a href="#InnoDB是如何保证隔离性的？" class="headerlink" title="InnoDB是如何保证隔离性的？"></a>InnoDB是如何保证隔离性的？</h1><p><strong>利用锁和 MVCC 机制</strong>。这里简单的介绍一下 MVCC 机制，也叫<strong>多版本并发控制</strong>，在使用 READ COMMITTD、REPEATABLE READ 这两种隔离级别的事务下，每条记录在更新的时候都会同时记录一条回滚操作，就会形成一个版本链，在执行普通的 SELECT 操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。</p>
<h1 id="事务的持久性如何保证？"><a href="#事务的持久性如何保证？" class="headerlink" title="事务的持久性如何保证？"></a>事务的持久性如何保证？</h1><p>持久性的定义：<strong>事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</strong></p>
<p>要保证持久性很简单，就是每次事务提交的时候，都将数据刷磁盘上，这样一定保证了安全性，但是要知道如果每次事务提交都将数据写入到磁盘的话，频繁的 IO 操作，成本太高，数据库的性能极低，所以这种方式不可取。</p>
<p>InnoDB 引擎是怎么解决的？<strong>InnoDB 引擎引入了一个中间层来解决这个持久性的问题，我们把这个叫做 redo log（归档日子）</strong>。</p>
<p>为什么要引入 redo log？redo log 可以保证持久化又可以保证数据库的性能，相比于直接刷盘，redo log 有以下两个优势：</p>
<ul>
<li>redo log体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。</li>
<li>redo log是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。</li>
</ul>
<p>InnoDB 引擎是怎么做的？当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log 里面，并更新内存，这个时候更新就算完成了。当数据库宕机重启的时候，会将 redo log 中的内容恢复到数据库中，再根据 undo log和 binlog 内容决定回滚数据还是提交数据。</p>
<h1 id="事务的一致性，指的是什么？"><a href="#事务的一致性，指的是什么？" class="headerlink" title="事务的一致性，指的是什么？"></a>事务的一致性，指的是什么？</h1><p><strong>一致性简单一点说就是数据执行前后都要处于一种合法的状态</strong>，比如身份证号不能重复，性别只能是男或者女，数据库应该体现为现实世界的一个映射。</p>
<p>要保证数据库的数据一致性，要在以下两个方面做努力：</p>
<ul>
<li><strong>利用数据库的一些特性来保证部分一致性需求</strong>：比如声明某个列为<code>NOT NULL</code> 来拒绝<code>NULL</code>值得插入等。</li>
<li><strong>绝大部分还是需要我们程序员在编写业务代码得时候来保证</strong>。</li>
</ul>
<h1 id="MVCC是什么，如何实现？"><a href="#MVCC是什么，如何实现？" class="headerlink" title="MVCC是什么，如何实现？"></a>MVCC是什么，如何实现？</h1><p>多版本并发控制，MVCC是一种并发控制的方法，减少事务中需要锁定的行数。</p>
<h1 id="InnoDB的MVCC实现原理是什么？"><a href="#InnoDB的MVCC实现原理是什么？" class="headerlink" title="InnoDB的MVCC实现原理是什么？"></a>InnoDB的MVCC实现原理是什么？</h1><blockquote>
<p>简答</p>
</blockquote>
<p>在每一行数据中额外保存两个隐藏的列：当前行创建时的版本号和删除时的版本号。数据会保存在某个时间点的快照。<code>RC</code>、<code>RR</code> 两种隔离级别的事务在执行普通的读操作时，通过访问版本链的方法，使得事务间的读写操作得以并发执行，从而提升系统性能 。</p>
<blockquote>
<p>加深理解</p>
</blockquote>
<p>这两个列，一个保存了行的创建时间，一个保存了行的过期时间（删除时间）。当然存储的并不是实际时间，而是<strong>系统版本号</strong>（sytem version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>
<p><strong>SELECT</strong></p>
<p>InnoDB 会根据以下两个条件检查每行记录：</p>
<ol>
<li>InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</li>
<li>行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。</li>
</ol>
<p>只有符合上述两个条件的记录，才能返回作为查询结果。</p>
<p><strong>INSERT</strong></p>
<p>InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</p>
<p><strong>DELETE</strong></p>
<p>InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</p>
<p><strong>UPDATE</strong></p>
<p>InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</p>
<p>保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。</p>
<blockquote>
<p>MVCC只在REPEATABLE READ和READ COMMITIED两个隔离级别下工作。其他两个隔离级别都和 MVCC不兼容 ，因为READ UNCOMMITIED总是读取最新的数据行，而不是符合当前事务版本的数据行。而SERIALIZABLE则会对所有读取的行都加锁。</p>
</blockquote>
<p>可参考：<br><a target="_blank" rel="noopener" href="https://www.codercto.com/a/88775.html">https://www.codercto.com/a/88775.html</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8845ddca3b23">https://www.jianshu.com/p/8845ddca3b23</a></p>
<h1 id="可重复读（repeatable-read）级别如何避免幻读？"><a href="#可重复读（repeatable-read）级别如何避免幻读？" class="headerlink" title="可重复读（repeatable read）级别如何避免幻读？"></a>可重复读（repeatable read）级别如何避免幻读？</h1><ul>
<li>在快照读读情况下，mysql通过mvcc来避免幻读。</li>
<li>在当前读读情况下，mysql通过next-key来避免幻读。</li>
</ul>
<blockquote>
<p>复习一下</p>
</blockquote>
<p><strong>什么是幻读</strong></p>
<p>事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。 同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象 发生了幻觉一样。</p>
<p><strong>什么是next-key锁</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以简单的理解为X锁+GAP锁</span><br></pre></td></tr></table></figure>

<p>**临键锁(Next-key Locks)：**是记录锁与间隙锁的组合，它的封锁范围，既包含索引记录，又包含索引区间。</p>
<ul>
<li><ul>
<li>临键锁主要是为了避免幻读。如果把事务的隔离级别降级为RC，临键锁则会失效。</li>
</ul>
</li>
</ul>
<p><strong>什么是快照读和当前读</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*   快照读：简单的select操作，属于快照读，不加锁。(当然，也有例外，下面会分析)</span><br><span class="line">    </span><br><span class="line">    *   select \* from table where ?;</span><br><span class="line">*   当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。</span><br><span class="line">    </span><br><span class="line">    *   select \* from table where ? lock in share mode;</span><br><span class="line">    *   select \* from table where ? for update;</span><br><span class="line">    *   insert into table values (…);</span><br><span class="line">    *   update table set ? where ?;</span><br><span class="line">    *   delete from table where ?;</span><br></pre></td></tr></table></figure>

<h1 id="乐观锁和悲观锁是什么，如何实现？"><a href="#乐观锁和悲观锁是什么，如何实现？" class="headerlink" title="乐观锁和悲观锁是什么，如何实现？"></a>乐观锁和悲观锁是什么，如何实现？</h1><p>1、乐观锁：先修改，保存时判断是够被更新过，应用级别，说白了就是自己写代码实现，是一种思想，可以基于版本号、更新时间戳可以实现，</p>
<p>2、悲观锁：先获取锁，再操作修改，数据库级别，比如sql后缀写 for update，是基于MySQL自带的功能。</p>
<h1 id="锁的粒度有哪几种？"><a href="#锁的粒度有哪几种？" class="headerlink" title="锁的粒度有哪几种？"></a>锁的粒度有哪几种？</h1><p>表级锁：开销小，加锁快，粒度大，锁冲突概率大，并发度低，适用于读多写少的情况。</p>
<p>页级锁：BDB存储引擎</p>
<p>行级锁：Innodb存储引擎，默认选项</p>
<p>注意，innoDB中行级锁是加在索引上的，因此只有命中索引的情况才会是行级锁，不然是表级锁，</p>
<h1 id="锁的兼容性对比"><a href="#锁的兼容性对比" class="headerlink" title="锁的兼容性对比"></a>锁的兼容性对比</h1><ul>
<li>S锁：也叫做读锁、共享锁，对应于 <code>select * from users where id =1 lock in share mode</code></li>
<li>X锁：也叫做写锁、排它锁、独占锁、互斥锁，对应于 <code>select * from users where id =1 for update</code></li>
</ul>
<p>可参考:</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31875702">https://zhuanlan.zhihu.com/p/31875702</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38238296/article/details/88362999">https://blog.csdn.net/qq_38238296/article/details/88362999</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/15/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="cmb0z941r0002usum2f6jccpj" data-title="MySQL面试题" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-面试" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/15/%E9%9D%A2%E8%AF%95/" class="article-date">
  <time class="dt-published" datetime="2025-05-15T03:12:21.000Z" itemprop="datePublished">2025-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/05/15/%E9%9D%A2%E8%AF%95/">面试</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>《登科后》- 孟郊<br>昔日龌龊不足夸， 今朝放荡思无涯。<br>春风得意马蹄疾，一日看尽长安花。</p>
<h1 id="怎么看待面试"><a href="#怎么看待面试" class="headerlink" title="怎么看待面试"></a>怎么看待面试</h1><ul>
<li>免费有人给你用心寻找知识盲区（像一束光照亮屋子里的灰犀牛）；</li>
<li>反问环节，帮你解答外面公司一般用什么技术，和你关心的问题；</li>
<li>对比当前环境和求职公司的环境，助你把握市场走向；</li>
<li>如果自己很牛，那么可以认清自身价值，别被老板PUA了（萌新多被PUA）；</li>
<li>面试失败，事后和面试官不会再联系了，不用担心面子问题；</li>
</ul>
<h1 id="保持自信心"><a href="#保持自信心" class="headerlink" title="保持自信心"></a>保持自信心</h1><blockquote>
<p>信心的基础只能是实力。</p>
</blockquote>
<h1 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h1><p>在程序开发这个行业，学历不是最重要的，梦想、兴趣和坚持才是最重要的。</p>
<p>成功&#x3D;（方向正确+创造性地工作）X 热情和信念</p>
<h1 id="请自我介绍一下"><a href="#请自我介绍一下" class="headerlink" title="请自我介绍一下?"></a>请自我介绍一下?</h1><p>答:我叫xxx,来自北京,20xx年毕业于xx大学计算机xx系,毕业后在武汉从事了x年的php开发工作,公司是一个外包公司,主要做微信开发,公众号推广,商城,论坛的开发</p>
<p>2.你在公司负责那些项目?</p>
<p>答:由于我们公司是一个外包公司,不可能只做一个项目,公司的项目都是交叉进行的,论坛,微信,商城我都做过?</p>
<p>3.你为什么来深圳?</p>
<p>答:因为我哥在这边,父母也希望兄弟间有个照应,而且深圳是一线城市,技术也比广西前沿一些</p>
<p>4.武汉使用什么前端框架和后端框架?</p>
<p>答:根据自己的区域回答</p>
<p>5.你做过那些模块?</p>
<p>答:登陆注册,商品管理,购物车模块,订单管理</p>
<p>6.你们公司是使用什么框架?</p>
<p>答:我们公司采用的是TP框架,运用的mysql+apache+php进行开发,因为TP框架是一个免费开源的,轻量级的php开发框架,而且是我们中国人自己开发的,也是国内用的比较多的,各种资料也比较齐全</p>
<h1 id="工作素养"><a href="#工作素养" class="headerlink" title="工作素养"></a>工作素养</h1><h2 id="如果你是技术组长-所带团队任务进度无法完成你该如何解决-如果在进度排满的前提下插入任务-你该如何保证总进度不延期-如果有的工程师今天预定任务没有完成-你该如何解决"><a href="#如果你是技术组长-所带团队任务进度无法完成你该如何解决-如果在进度排满的前提下插入任务-你该如何保证总进度不延期-如果有的工程师今天预定任务没有完成-你该如何解决" class="headerlink" title="如果你是技术组长,所带团队任务进度无法完成你该如何解决?如果在进度排满的前提下插入任务,你该如何保证总进度不延期?如果有的工程师今天预定任务没有完成,你该如何解决?"></a>如果你是技术组长,所带团队任务进度无法完成你该如何解决?如果在进度排满的前提下插入任务,你该如何保证总进度不延期?如果有的工程师今天预定任务没有完成,你该如何解决?</h2><p>主要考察你的考察带队能力。<br>注意不是所有的问题都有非常肯定和完美的答案，思考和解决问题的方式，比回答问题本身更为重要。</p>
<h2 id="你对我们的薪资待遇了解吗？可以接受吗？"><a href="#你对我们的薪资待遇了解吗？可以接受吗？" class="headerlink" title="你对我们的薪资待遇了解吗？可以接受吗？"></a>你对我们的薪资待遇了解吗？可以接受吗？</h2><p>这个问题主要也是看你的要求是否与公司给出的条件符合。如果你的要求高过公司给的条件很多，需求超出，那么肯定是没办法满足你的条件。如果能接受，OK，继续往下聊。很多大型公司会有宣讲会，会明确的说出本公司的薪资福利待遇，没有宣讲会的，多数也会在招聘信息中说明，建议最好提前了解一下，在可以接受薪资水平的前提下去面试，省去双方不必要的麻烦。</p>
<h2 id="简单说明一下自己的优缺点"><a href="#简单说明一下自己的优缺点" class="headerlink" title="简单说明一下自己的优缺点"></a>简单说明一下自己的优缺点</h2><p>这个问题答好了是送分题，打不好就是致命的一击。为什么这么说呢？</p>
<p>①在回答优点的时候，要充分的肯定自己，突出工作能力，让面试官看到你的自信，也可多说一些性格方面的优势，比如面试导购，你可以说自己性格外向，口才比较好。</p>
<p>②说缺点的时候要注意了，不是真的让你说缺点，要学会巧妙的转化。有些人一上来就说自己的缺点是懒，那么不好意思，你一个懒人，我们凭什么要录用你呢？有时候你以为自己是实诚，殊不知就是这样才会被淘汰。</p>
<p>③这样说缺点才会加分：多说经验上的一些缺点，比如缺少经验、社会阅历较浅、过分追求完美、太过小心谨慎等，这样说，就可以完美的将缺点转化为有点，记住，一定要少说一些性格上的缺点！因为性格上的缺点是很难改正的，面试官会可能认为这些缺点会影响日后的工作以及同事关系。</p>
<h2 id="职业规划是什么？"><a href="#职业规划是什么？" class="headerlink" title="职业规划是什么？"></a>职业规划是什么？</h2><blockquote>
<p>我觉得最好的回答，就是在自己喜欢的工作中，实战中锻炼自己，提升技术，追求精通一门技术栈，拓展知识面和能力范围。打造完备的知识体系，达到一门精通，遍地开花的技术水平。</p>
</blockquote>
<p>1.明确职业定位</p>
<p>明确职业定位是职业规划的关键环节，围绕其展开回答，才能有的放矢。</p>
<p>首先，明确自己适合做什么；其次，告诉HR你擅长做什么；最后，依据个人爱好、特长、能力、经验等，把自己放在一个合适的岗位上。</p>
<p>2.分析职业定位</p>
<p>可以从专业知识和技能、兴趣爱好、职业经历、人脉、价值观等因素中选择你认为重要的以及企业看重的因素进行分析。</p>
<p>3.分期制定目标</p>
<p>对于职业目标的设定，应分为三个目标：短期目标（1-2年，清晰明确，切合实际）、中期目标（3-5年，有所创新）和长期目标（5年以上，挑战性）。</p>
<p>4.避谈禁忌话题</p>
<p>在回答这个问题时，要知道有些话题是千万不能提的。比如在职业规划中提到结婚生子的问题，这是一个非常敏感的话题，回答得不好面试通过率将会大大降低。</p>
<p>此外，自己在近几年有创业或留学的计划也不能提，因为企业培养人才是非常不容易的，没有企业愿意录用一个两三年后就离职的人。</p>
<p>5.切忌好高骛远</p>
<p>职业规划遵循一个最重要的原则，就是要切合实际，切忌好高骛远。</p>
<p>如果你应聘的只是一个普通岗位，给自己的职业规划却是几年升主管、几年当经理这类的话，这么不切实际的规划，绝对是巨大的减分。</p>
<p>总之，职业规划是规划职业，不是规划升职加薪，更多的应该规划专业技能方面的提升。</p>
<h2 id="你对加班的看法？"><a href="#你对加班的看法？" class="headerlink" title="你对加班的看法？"></a>你对加班的看法？</h2><p>加班大家不见得反对。自己负责的事，偶尔有个重大事件，新项目开始，订单多到爆表的时刻，项目没做完，加加班很正常。<br>但是，反对的就是那种把加班当做一种常态的情况：<br>1、要么强行规定额外的工作时间<br>2、要么就是过重的任务量。<br>这才是大家所讨厌的，特别是前一种。<br>这些在哪个工作，基本都适用</p>
<h2 id="你觉得你个性上最大的优点是什么？"><a href="#你觉得你个性上最大的优点是什么？" class="headerlink" title="你觉得你个性上最大的优点是什么？"></a>你觉得你个性上最大的优点是什么？</h2><p>擅长将要做的事情逻辑化，严谨化，流程化；其次，将其分拆成小的项目。</p>
<h2 id="说说你对行业、技术发展趋势的看法？"><a href="#说说你对行业、技术发展趋势的看法？" class="headerlink" title="说说你对行业、技术发展趋势的看法？"></a>说说你对行业、技术发展趋势的看法？</h2><p>我觉得软件开发产业的管理瓶颈不在于开发流程（当然开发流程确实能减少开发过程的很多问题），而是最基本的业务流程和成员激励的问题。一个没有什么流程的团队可以做出很棒的软件，一个流程严格的团队也可以一无所成。</p>
<p>软件行业在我看来最大的管理弊病在于，很多时候是外行管理内行，一群对技术模模糊糊知道一些的管理层来管理具体做事的员工。对于走技术路线升上去的经理，情况稍好，然而期待他能懂组里所有人做的事，也比较难。</p>
<p>外行管理内行的最大害处，在于不能以产出来衡量业绩。比如，一个BUG，也许很难但是我一天就改好了，可能还不如一个不那么难但是让人觉得工作态度端正的人花几天改好的人评价好。</p>
<h2 id="建议-1"><a href="#建议-1" class="headerlink" title="建议"></a>建议</h2><p>一些大厂都有完备的招聘机制，会有一套职业素养和道德考察题库。</p>
<p>比如我面某度，需要做3，4百道单选多选阅读理解题，基本是围绕职业素养的考察出题的。</p>
<p>这里开头会提示面试者不要关注哪个才是正确答案，要跟随本心去选择选项。此处让面试者放松警惕，实际上前面技术面和hr面都过了，没必要非要较真挂在这里。所以希望大家在做题时，跟随自己的实际经济情况去给出答案。</p>
<h1 id="离职前要先找好下家吗？"><a href="#离职前要先找好下家吗？" class="headerlink" title="离职前要先找好下家吗？"></a>离职前要先找好下家吗？</h1><p><strong>如果是朋友，我会劝她骑驴找马；但如果是招人，更喜欢裸辞的人。</strong></p>
<p>对，就是这么双标！</p>
<h2 id="什么样的人适合裸辞"><a href="#什么样的人适合裸辞" class="headerlink" title="什么样的人适合裸辞"></a>什么样的人适合裸辞</h2><p><strong>先来说下什么样的人适合裸辞，大家可以对号入座一下：</strong></p>
<p><strong>1、能力上天</strong>——如果对于你来说，从来都是猎头call不停，offer一大堆，那你还有什么好怕的，一言不合，爷不待见了，不干了！果断裸辞！</p>
<p><strong>2、家里有矿</strong>——如果你一人吃饱全家不饿，而且有足够的余粮，或是身边有许多外援，压根不用担心生存的问题，或者本身就是“富二代，官二代“，那你当然有资本裸辞！</p>
<p><strong>3、需要放松</strong>——如果你目前的工作状态已经严重影响到你的心情，那么建议你裸辞去彻底放松调整下。世界那么大，你要去看看！但是记得要及时收心！</p>
<p><strong>4、拖延症晚期</strong>——明明对现有的工作非常不满意，仗着有退路，就迟迟不肯跨出第一步。简历不想改，面试不想去，总是把找工作这件事放着，可放着放着，就有熬过了1年。有的时候，不破釜沉舟逼自己一把，就不知道自己有多优秀！</p>
<h2 id="为什么劝你骑驴找马"><a href="#为什么劝你骑驴找马" class="headerlink" title="为什么劝你骑驴找马"></a>为什么劝你骑驴找马</h2><p><strong>先问自己能不能承受裸辞带来的这些压力：</strong></p>
<h3 id="1、生活方面"><a href="#1、生活方面" class="headerlink" title="1、生活方面"></a>1、生活方面</h3><p>裸辞虽爽，生活还将继续。一旦裸辞，你就需要面对各种压力。</p>
<p>社保断缴，房租要交，朋友聚餐要AA，护肤品刚好用完。</p>
<p>这还仅限于那些没有太大压力的沪飘北漂来讲。</p>
<p>而对于上有老，下有小，还要还房贷的中年人，如果裸辞，绝对寝食难安。</p>
<p>生活的每一天都需要成本，<strong>裸辞需要坚强的经济后盾。</strong></p>
<h3 id="2、工作方面"><a href="#2、工作方面" class="headerlink" title="2、工作方面"></a>2、工作方面</h3><p><strong>对任何人而言，找工作都是有底线的，超过底线，人就变得急躁、不自信，甚至有些“饥不择食”。</strong></p>
<p>一般而言，离职后三个月以内是重新就业的黄金时期，三个月后尚未找到工作，会产生明显的焦虑或不自信；超过六个月，已达到心理承受极限，整个人可能变得颓废，很容易委曲求全，影响自己的职业生涯规划。</p>
<h3 id="3、心理方面"><a href="#3、心理方面" class="headerlink" title="3、心理方面"></a>3、心理方面</h3><p>裸辞之前想的特别好，要给自己一点时间充电放松。真正做到的没几个，依旧是晚睡晚起，天天抱着手机“杀时间”。</p>
<p><strong>对于那些自我控制力不足的人来讲，没有了工作的约束，只会更加放任更加沉沦。</strong></p>
<h2 id="企业或者HR如何看待裸辞和骑驴找马的人？"><a href="#企业或者HR如何看待裸辞和骑驴找马的人？" class="headerlink" title="企业或者HR如何看待裸辞和骑驴找马的人？"></a>企业或者HR如何看待裸辞和骑驴找马的人？</h2><p>首先明确一点，在劳动合同法或者其他法律法规中并没有明确禁止员工骑驴找马。<strong>但对于这两类求职者，面试所关注的点是不一样的。</strong></p>
<p><strong>对于裸辞者：</strong></p>
<h3 id="1、裸辞的原因"><a href="#1、裸辞的原因" class="headerlink" title="1、裸辞的原因"></a>1、裸辞的原因</h3><p>辞职原因很多，见过的离职原因也五花八门，有些离职理由简直让人忍俊不禁。</p>
<blockquote>
<p>老板喜欢潜规则？（仔细研究一下她的长相）<br>同事关系不和睦？（那跟我们会不会和睦呢？）<br>跟前女友在一个公司，分手了不想再见面？（情绪控制能力不佳）<br>公司倒闭？（一个人工作三家公司，三家公司都倒闭了，录用他我们会不会也有倒闭风险？）<br>老公不喜欢她的公司？（今天带老公过来面试了吗？万一也不喜欢我们公司怎么办？）<br>加班太多？（我们也加班呢，慎重考虑一下吧）<br>工作太清闲？</p>
</blockquote>
<p>每个原因背后都有深层次的原因，只要不是特别离谱的离职原因，主要关注的就是：<strong>主动离职还是被动离职。</strong></p>
<p><strong>TA在上一家被动离职，在我们这里依然会被动离职。</strong></p>
<h3 id="2、上一份工作的间隔时间"><a href="#2、上一份工作的间隔时间" class="headerlink" title="2、上一份工作的间隔时间"></a>2、上一份工作的间隔时间</h3><p>如果上一份工作时间间隔太久，主要会考虑以下几点</p>
<blockquote>
<p>是一直在找工作找不到？能力方面是不是有问题？<br>是不是在其他公司入职？但是没有过试用期？简历上并没有显示，有不诚实的嫌疑。</p>
</blockquote>
<p><strong>对于骑驴找马者：</strong></p>
<h3 id="1、为什么要离职？"><a href="#1、为什么要离职？" class="headerlink" title="1、为什么要离职？"></a>1、为什么要离职？</h3><p>跟裸辞类似，如果应聘者离职的情形因为钱，因为发展平台，因为老板的性格，而这些所谓种种的的理由在新公司也很有可能出现。问清楚这个问题，可以用来判断应聘者与企业的契合度。</p>
<h3 id="2、要想怎样的工作？"><a href="#2、要想怎样的工作？" class="headerlink" title="2、要想怎样的工作？"></a>2、要想怎样的工作？</h3><p>应聘者理想中的工作是什么样的？这是HR想知道的，然后才能判断应聘者要找的马是不是自己这匹马。</p>
<p>问应聘者找新工作的标准有哪些？对新工作有哪些期望？如果应聘者想要的条件跟公司的实际情况相差甚远，正所谓强扭的瓜不甜，即使是人才也会忍痛放弃，因为合适的才是最好的。</p>
<h3 id="3、什么时候可以入职？"><a href="#3、什么时候可以入职？" class="headerlink" title="3、什么时候可以入职？"></a>3、什么时候可以入职？</h3><p>问这个问题其实主要想要知道，<strong>应聘者是否已经提出了离职？交接期多长时间。</strong></p>
<p>如果没有提离职，那就会看职位紧急与否，不紧急可以考虑，紧急职位基本上不考虑了。</p>
<p>没有提出离职，但是本人说交接期很短，证明他在前公司的作用并不是很大，那他口中的能力要打个折扣。</p>
<p>如果没有提出离职，交接期很短，但是能提供详细的工作计划，接手的人很快就能上手，表示计划性很好，总结能力不错，可以考虑。</p>
<p>以上只是基于以前的经验给出的一些建议，裸辞与否还需要根据自己的实际情况考虑，<strong>而求职也是一个双方互选的过程，适合自己的才是最好的！</strong></p>
<h1 id="反问环节"><a href="#反问环节" class="headerlink" title="反问环节"></a>反问环节</h1><ul>
<li>工作挑战大不大?</li>
<li>项目开发是否写测试用例，项目上线先是否会进行压力测试</li>
<li>业务前景如何?</li>
<li>技术氛围如何?</li>
<li>根据这次面试，对个人进行评价，帮助成长</li>
<li>公司发展方向、融资计划</li>
<li>是否有加班费&#x2F;调休，公司福利，社保公积金缴纳基数</li>
</ul>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>如果手里有几个offer，那么在选择的时候，需要关注这些点：</p>
<p>表层：一看薪资，二看福利待遇，三看晋升通道，四看公司发展前景，五看假期情况；</p>
<p>深层：一看价值观匹配程度，二看职业规划匹配程度，三看公司战略规划；</p>
<blockquote>
<p>避坑icu，拥抱wlb。</p>
</blockquote>
<p>最主要还得看自己想要什么。</p>
<h1 id="扩展学习"><a href="#扩展学习" class="headerlink" title="扩展学习"></a>扩展学习</h1><h2 id="一份自我介绍和项目经验demo参考"><a href="#一份自我介绍和项目经验demo参考" class="headerlink" title="一份自我介绍和项目经验demo参考"></a>一份自我介绍和项目经验demo参考</h2><p><a target="_blank" rel="noopener" href="https://github.com/disxo/PHP-interview-myway/blob/master/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D.md">https://github.com/disxo/PHP-interview-myway/blob/master/项目介绍.md</a></p>
<h2 id="在线做题（牛客）"><a href="#在线做题（牛客）" class="headerlink" title="在线做题（牛客）"></a>在线做题（牛客）</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/company/home/code/139?codeType=1">https://www.nowcoder.com/company/home/code/139?codeType=1</a></p>
<h2 id="面经合集（牛客）"><a href="#面经合集（牛客）" class="headerlink" title="面经合集（牛客）"></a>面经合集（牛客）</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/experience?tagId=649">https://www.nowcoder.com/discuss/experience?tagId=649</a></p>
<h2 id="面经合集（思否）"><a href="#面经合集（思否）" class="headerlink" title="面经合集（思否）"></a>面经合集（思否）</h2><p><a target="_blank" rel="noopener" href="https://segmentfault.com/t/%E9%9D%A2%E8%AF%95">https://segmentfault.com/t/面试</a></p>
<h2 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h2><p><a target="_blank" rel="noopener" href="https://github.com/disxo/PHP-interview-myway">https://github.com/disxo/PHP-interview-myway</a></p>
<h2 id="PHP面试2020（看云）"><a href="#PHP面试2020（看云）" class="headerlink" title="PHP面试2020（看云）"></a>PHP面试2020（看云）</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/martist/be_new_friends/1677644">https://www.kancloud.cn/martist/be_new_friends/1677644</a></p>
<h2 id="后端架构师技术图谱（github）"><a href="#后端架构师技术图谱（github）" class="headerlink" title="后端架构师技术图谱（github）"></a>后端架构师技术图谱（github）</h2><p><a target="_blank" rel="noopener" href="https://github.com/xingshaocheng/architect-awesome/blob/master/README.md">https://github.com/xingshaocheng/architect-awesome/blob/master/README.md</a></p>
<h2 id="程序员修炼之路：你该知道的-7-个必经阶段"><a href="#程序员修炼之路：你该知道的-7-个必经阶段" class="headerlink" title="程序员修炼之路：你该知道的 7 个必经阶段"></a>程序员修炼之路：你该知道的 7 个必经阶段</h2><p><a target="_blank" rel="noopener" href="https://github.com/yefangyong/PHP-Interview/blob/master/docs/%E8%BD%AF%E6%8A%80%E8%83%BD/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E8%B7%AF%EF%BC%9A%E4%BD%A0%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%207%20%E4%B8%AA%E5%BF%85%E7%BB%8F%E9%98%B6%E6%AE%B5.md">https://github.com/yefangyong/PHP-Interview/blob/master/docs/软技能/程序员修炼之路：你该知道的 7 个必经阶段.md</a></p>
<h2 id="剑指offer面试题（PHP实现）"><a href="#剑指offer面试题（PHP实现）" class="headerlink" title="剑指offer面试题（PHP实现）"></a>剑指offer面试题（PHP实现）</h2><p><a target="_blank" rel="noopener" href="https://github.com/bigbignerd/offer">https://github.com/bigbignerd/offer</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/15/%E9%9D%A2%E8%AF%95/" data-id="cmb0z941w0008usum3rbm8ob6" data-title="面试" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-PHP笔试题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/15/PHP%E7%AC%94%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2025-05-15T03:11:58.000Z" itemprop="datePublished">2025-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/05/15/PHP%E7%AC%94%E8%AF%95%E9%A2%98/">PHP笔试题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="九九乘法表-for-实现："><a href="#九九乘法表-for-实现：" class="headerlink" title="九九乘法表 for 实现："></a>九九乘法表 for 实现：</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">1</span>;<span class="variable">$i</span>&lt;<span class="number">10</span>;<span class="variable">$i</span>++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="variable">$j</span>=<span class="number">1</span>;<span class="variable">$j</span>&lt;=<span class="variable">$i</span>;<span class="variable">$j</span>++)&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="variable">$i</span>.<span class="string">&#x27;*&#x27;</span>.<span class="variable">$j</span>.<span class="string">&#x27;=&#x27;</span>.<span class="variable">$i</span>*<span class="variable">$j</span>.<span class="string">&#x27;   &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&#x27;&lt;br /&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="‘a’-‘b’-‘c’-转成’abc’"><a href="#‘a’-‘b’-‘c’-转成’abc’" class="headerlink" title="[‘a’, ‘b’, ‘c’]转成’abc’"></a>[‘a’, ‘b’, ‘c’]转成’abc’</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;&#x27;</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">join</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="获取’aAbB’中A首次出现的位置"><a href="#获取’aAbB’中A首次出现的位置" class="headerlink" title="获取’aAbB’中A首次出现的位置"></a>获取’aAbB’中A首次出现的位置</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$str</span>=<span class="string">&#x27;aAbB&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">strpos</span>(<span class="variable">$str</span>, <span class="string">&#x27;A&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="字符串反序，将‘1234567890’-转换成-‘0987654321’"><a href="#字符串反序，将‘1234567890’-转换成-‘0987654321’" class="headerlink" title="字符串反序，将‘1234567890’ 转换成 ‘0987654321’"></a>字符串反序，将‘1234567890’ 转换成 ‘0987654321’</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.使用函数</span></span><br><span class="line"><span class="variable">$str</span> = <span class="string">&#x27;1234567890&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">strrev</span>(<span class="variable">$str</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.不使用函数</span></span><br><span class="line"><span class="variable">$newStr</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="variable">$i</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">isset</span>(<span class="variable">$str</span>[<span class="variable">$i</span>]) &amp;&amp; <span class="variable">$str</span>[<span class="variable">$i</span>] != <span class="literal">null</span>) &#123;</span><br><span class="line">	<span class="variable">$newStr</span> = <span class="variable">$str</span>[<span class="variable">$i</span>++] . <span class="variable">$newStr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$newStr</span>;</span><br></pre></td></tr></table></figure>

<h1 id="用递归求阶乘"><a href="#用递归求阶乘" class="headerlink" title="用递归求阶乘"></a>用递归求阶乘</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"><span class="variable">$n</span></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 基本情况：如果n为0或1，则返回1</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="variable">$n</span> == <span class="number">0</span> || <span class="variable">$n</span> == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="variable">$n</span> * <span class="title function_ invoke__">F</span>(<span class="variable">$n</span> - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">F</span>(<span class="number">5</span>);	<span class="comment">// 120</span></span><br></pre></td></tr></table></figure>

<h1 id="将字符长fang-zhi-gang-转化为驼峰法的形式：FangZhiGang"><a href="#将字符长fang-zhi-gang-转化为驼峰法的形式：FangZhiGang" class="headerlink" title="将字符长fang-zhi-gang 转化为驼峰法的形式：FangZhiGang"></a>将字符长fang-zhi-gang 转化为驼峰法的形式：FangZhiGang</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;  </span><br><span class="line">	<span class="variable">$arr</span> = <span class="title function_ invoke__">explode</span>(<span class="string">&#x27;-&#x27;</span>, <span class="variable">$str</span>);   </span><br><span class="line">	<span class="variable">$str</span> = <span class="title function_ invoke__">implode</span>(<span class="string">&#x27; &#x27;</span>, <span class="variable">$arr</span>);   </span><br><span class="line">	<span class="variable">$str</span> = <span class="title function_ invoke__">ucwords</span>(<span class="variable">$str</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_ invoke__">str_replace</span>(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>, <span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">F</span>(<span class="string">&quot;fang-zhi-gang&quot;</span>)); <span class="comment">//FangZhiGang</span></span><br></pre></td></tr></table></figure>

<h1 id="数组内置的排序方法有哪些？"><a href="#数组内置的排序方法有哪些？" class="headerlink" title="数组内置的排序方法有哪些？"></a>数组内置的排序方法有哪些？</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">sort</span>(<span class="variable">$array</span>);	<span class="comment">//数组升序排序</span></span><br><span class="line"><span class="title function_ invoke__">rsort</span>(<span class="variable">$array</span>);	<span class="comment">//数组降序排序</span></span><br><span class="line"> </span><br><span class="line"><span class="title function_ invoke__">asort</span>(<span class="variable">$array</span>);	<span class="comment">//根据值，以升序对关联数组进行排序</span></span><br><span class="line"><span class="title function_ invoke__">ksort</span>(<span class="variable">$array</span>);	<span class="comment">//根据建，以升序对关联数组进行排序</span></span><br><span class="line"> </span><br><span class="line"><span class="title function_ invoke__">arsort</span>(<span class="variable">$array</span>);	<span class="comment">//根据值，以降序对关联数组进行排序</span></span><br><span class="line"><span class="title function_ invoke__">krsort</span>(<span class="variable">$array</span>);	<span class="comment">//根据键，以降序对关联数组进行排序</span></span><br></pre></td></tr></table></figure>

<h1 id="客户端IP与服务器IP"><a href="#客户端IP与服务器IP" class="headerlink" title="客户端IP与服务器IP"></a>客户端IP与服务器IP</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$_SERVER</span>[<span class="string">&quot;REMOTE_ADDR&quot;</span>]</span><br><span class="line"><span class="variable">$_SERVER</span>[<span class="string">&quot;SERVER_ADDR&quot;</span>]</span><br></pre></td></tr></table></figure>

<h1 id="不使用第三个变量实现交换两个变量的值"><a href="#不使用第三个变量实现交换两个变量的值" class="headerlink" title="不使用第三个变量实现交换两个变量的值"></a>不使用第三个变量实现交换两个变量的值</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(<span class="variable">$b</span>, <span class="variable">$a</span>) = <span class="keyword">array</span>(<span class="variable">$a</span>, <span class="variable">$b</span>);</span><br></pre></td></tr></table></figure>

<h1 id="获取文件的扩展名"><a href="#获取文件的扩展名" class="headerlink" title="获取文件的扩展名"></a>获取文件的扩展名</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_extension</span>(<span class="params"><span class="variable">$file</span></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_ invoke__">end</span>(<span class="title function_ invoke__">explode</span>(<span class="string">&#x27;.&#x27;</span>, <span class="variable">$file</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">get_extension</span>(<span class="string">&#x27;test.php&#x27;</span>); <span class="comment">//php</span></span><br></pre></td></tr></table></figure>

<h1 id="打印出前一天的时间格式是2017-3-22-22-21-21"><a href="#打印出前一天的时间格式是2017-3-22-22-21-21" class="headerlink" title="打印出前一天的时间格式是2017-3-22 22:21:21"></a>打印出前一天的时间格式是2017-3-22 22:21:21</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">date</span>(<span class="string">&quot;Y-m-d H:i:s&quot;</span>, <span class="title function_ invoke__">strtotime</span>(<span class="string">&quot;-1 days&quot;</span>));</span><br></pre></td></tr></table></figure>

<h1 id="用header-函数实现页面404错误提示"><a href="#用header-函数实现页面404错误提示" class="headerlink" title="用header()函数实现页面404错误提示"></a>用header()函数实现页面404错误提示</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;HTTP/1.1 404 Not Found&quot;</span>); <span class="comment">// 设置HTTP状态码为404</span></span><br></pre></td></tr></table></figure>

<h1 id="PHP-数组在底层的实现原理"><a href="#PHP-数组在底层的实现原理" class="headerlink" title="PHP 数组在底层的实现原理"></a>PHP 数组在底层的实现原理</h1><p>PHP数组在底层的实现原理可以分为两种类型：基于哈希表的实现和基于有序列表的实现。</p>
<h2 id="1、基于哈希表的实现"><a href="#1、基于哈希表的实现" class="headerlink" title="1、基于哈希表的实现"></a>1、基于哈希表的实现</h2><p>PHP 数组的基于哈希表的实现是指，在内部实现中，PHP 使用了哈希表来实现数组的存储和访问操作。</p>
<p>哈希表是一种数据结构，它可以将元素存储在数组中，并通过一个哈希函数将元素的键映射到数组的索引位置。哈希函数的作用是将任意长度的输入数据（即键）映射为固定长度的哈希值，并将该哈希值作为索引。</p>
<p>在 PHP 数组中，键值对被存储在一个桶中，每个桶可以包含一个或多个键值对。当要访问一个特定的键值对时，PHP 会先使用哈希函数来计算该键对应的哈希值，然后根据该哈希值找到对应的桶，最后再在桶内进行线性搜索，直到找到对应的键值对。</p>
<p>这种基于哈希表的实现具有快速的查找速度，但会占用更多的内存。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的数组</span></span><br><span class="line"><span class="variable">$myarray</span> = <span class="keyword">array</span>();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 向数组中添加键值对</span></span><br><span class="line"><span class="variable">$myarray</span>[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"><span class="variable">$myarray</span>[<span class="string">&quot;age&quot;</span>] = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 访问数组的元素</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;姓名：&quot;</span> . <span class="variable">$myarray</span>[<span class="string">&quot;name&quot;</span>] . <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;年龄：&quot;</span> . <span class="variable">$myarray</span>[<span class="string">&quot;age&quot;</span>] . <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这里使用了 <code>$myarray</code> 哈希表来存储数组元素。每个元素都被存储在一个桶中，并通过一个哈希函数将键映射到桶的索引位置。在访问数组元素时，可以通过键值直接访问对应的桶，从而快速地找到元素。</p>
<h2 id="2、基于有序列表的实现"><a href="#2、基于有序列表的实现" class="headerlink" title="2、基于有序列表的实现"></a>2、基于有序列表的实现</h2><p>PHP 数组的基于有序列表的实现是指，在内部实现中，PHP 使用了双向链表来实现数组的存储和访问操作。</p>
<p>在这种实现方式中，每个键值对被存储在一个节点中，节点之间通过指针连接，构成一个双向链表。同时，还会按照键的顺序进行排序，以方便查找和遍历。</p>
<p>在访问数组元素时，PHP 会先使用二分查找算法来查找对应的键值对，然后再返回相应的值。由于数组是有序的，因此二分查找的效率非常高。</p>
<p>这种基于有序列表的实现具有较低的内存占用，但在插入和删除元素时可能会比较耗时。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的数组</span></span><br><span class="line"><span class="variable">$myarray</span> = <span class="keyword">array</span>();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 向数组中添加键值对</span></span><br><span class="line"><span class="variable">$myarray</span>[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"><span class="variable">$myarray</span>[<span class="string">&quot;age&quot;</span>] = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 按照键的顺序遍历数组</span></span><br><span class="line"><span class="title function_ invoke__">ksort</span>(<span class="variable">$myarray</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$myarray</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$value</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$key</span> =&gt; <span class="subst">$value</span> &lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 查找数组中的元素</span></span><br><span class="line"><span class="variable">$search_key</span> = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"><span class="variable">$index</span> = <span class="title function_ invoke__">binary_search</span>(<span class="variable">$myarray</span>, <span class="variable">$search_key</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$index</span> !== <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;元素 &#x27;<span class="subst">$search_key</span>&#x27; 的值为：&quot;</span> . <span class="variable">$myarray</span>[<span class="variable">$search_key</span>] . <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;元素 &#x27;<span class="subst">$search_key</span>&#x27; 不存在&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 二分查找算法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binary_search</span>(<span class="params"><span class="variable">$array</span>, <span class="variable">$key</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$low</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable">$high</span> = <span class="title function_ invoke__">count</span>(<span class="variable">$array</span>) - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$low</span> &lt;= <span class="variable">$high</span>) &#123;</span><br><span class="line">        <span class="variable">$mid</span> = <span class="title function_ invoke__">intval</span>((<span class="variable">$low</span> + <span class="variable">$high</span>) / <span class="number">2</span>);</span><br><span class="line">        <span class="variable">$mid_key</span> = <span class="title function_ invoke__">array_keys</span>(<span class="variable">$array</span>)[<span class="variable">$mid</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$mid_key</span> == <span class="variable">$key</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$mid</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">$mid_key</span> &lt; <span class="variable">$key</span>) &#123;</span><br><span class="line">            <span class="variable">$low</span> = <span class="variable">$mid</span> + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$high</span> = <span class="variable">$mid</span> - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了 $myarray 双向链表来存储数组元素，并按照键的顺序进行了排序。在遍历数组时，可以直接按照节点的顺序进行遍历。在查找数组元素时，可以使用二分查找算法来在有序列表中查找对应的节点，从而快速地找到元素。</p>
<p>总结：</p>
<p>无论使用哪种底层实现方式，PHP 数组都是非常方便和实用的数据结构。底层实现的选择取决于应用场景和需求。如果需要快速的查找操作，可以选择基于哈希表的实现，如果需要较低的内存消耗，则可以选择基于有序列表的实现。</p>
<h1 id="1-2-3-…-99-100"><a href="#1-2-3-…-99-100" class="headerlink" title="1+2+3+…+99+100&#x3D;()"></a>1+2+3+…+99+100&#x3D;()</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1：使用循环</span></span><br><span class="line"><span class="variable">$sum</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">1</span>; <span class="variable">$i</span> &lt;= <span class="number">100</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">	<span class="variable">$sum</span> += <span class="variable">$i</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$sum</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：使用等差数列求和公式</span></span><br><span class="line"><span class="comment">// 已知首项和末项时：直接使用Sₙ = n(a₁ + aₙ)/2，计算效率更高</span></span><br><span class="line"><span class="variable">$sum</span> = (<span class="number">100</span> * (<span class="number">1</span> + <span class="number">100</span>)) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$sum</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3：使用range函数和array_sum函数</span></span><br><span class="line"><span class="variable">$numbers</span> = <span class="title function_ invoke__">range</span>(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"><span class="variable">$sum</span> = <span class="title function_ invoke__">array_sum</span>(<span class="variable">$numbers</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$sum</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法4：使用递归（不推荐，除非有特殊需求）</span></span><br><span class="line"><span class="comment">// 虽然递归通常不是求和的最佳选择（因为它可能导致栈溢出或效率问题），但为了完整性，这里也展示一个递归方法：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"><span class="variable">$n</span></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="variable">$n</span> == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="variable">$n</span> + <span class="title function_ invoke__">sum</span>(<span class="variable">$n</span> - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">sum</span>(<span class="number">100</span>); <span class="comment">// 这将计算从1到100的和。但请注意，这并不是最高效的方法。</span></span><br></pre></td></tr></table></figure>

<h1 id="你该怎样优化这段代码？"><a href="#你该怎样优化这段代码？" class="headerlink" title="你该怎样优化这段代码？"></a>你该怎样优化这段代码？</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span></span><br><span class="line">	<span class="keyword">echo</span>(<span class="string">&quot;&lt;p&gt;Search results for query: &quot;</span> . <span class="variable">$_GET</span>[<span class="string">&#x27;query&#x27;</span>] . <span class="string">&quot;.&lt;/p&gt;&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;query&#x27;</span>])) &#123; </span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&#x27;&lt;p&gt;Search results for query: &#x27;</span>,</span><br><span class="line">	<span class="title function_ invoke__">htmlspecialchars</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;query&#x27;</span>], ENT_QUOTES), <span class="string">&#x27;.&lt;/p&gt;&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>能写出这样代码的人，99%可以被录用。理由如下： </p>
<ul>
<li><?被替换成了<?php，这样更符合 XML 规范。 
</li>
<li><p>在输出$_GET[‘query’]的值之前先判断它是否为空。 </p>
</li>
<li><p>echo 命令中多余的括号被去掉了。 </p>
</li>
<li><p>字符串用单引号限定，从而节省了 PHP 从字符串中搜索可替换的变量的时间。 </p>
</li>
<li><p>用逗号代替句号，节省了 echo 的时间。 </p>
</li>
<li><p>将 ENT_QUOTES 标识传递给 htmlspecialchars 函数，从而保证单引号也会被转义。虽然这并是最</p>
</li>
</ul>
<p>主要的，但也算是一个良好习惯。</p>
<h1 id="获取客户端和服务器端的-IP-地址？"><a href="#获取客户端和服务器端的-IP-地址？" class="headerlink" title="获取客户端和服务器端的 IP 地址？"></a>获取客户端和服务器端的 IP 地址？</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">本题考核面试者对 PHP 网络函数的掌握程度，以及扩展能力。获取客户端和服务器端 IP 地址可以通</span><br><span class="line">过 <span class="title function_ invoke__">getenv</span>()函数来实现。但是，如果是获取指定域名的 IP 地址，那么就需要使用 <span class="title function_ invoke__">gethostbyname</span>()函数。</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">getenv</span>(<span class="string">&#x27;REMOTE_ADDR&#x27;</span>); <span class="comment">//获取客户端 IP 地址 $_SERVER[&#x27;REMOTE_ADDR&#x27;]</span></span><br><span class="line"><span class="title function_ invoke__">getenv</span>(<span class="string">&#x27;SERVER_ADDR&#x27;</span>); <span class="comment">//获取服务器端 IP 地址 $_SERVER[&#x27;SERVER_ADDR&#x27;]</span></span><br><span class="line"><span class="title function_ invoke__">gethostbyname</span>(<span class="string">&#x27;www.mingribook.com&#x27;</span>); <span class="comment">//获取指定域名的 IP 地址</span></span><br></pre></td></tr></table></figure>

<h1 id="如何实现-PHP-与-JSP-的交互？"><a href="#如何实现-PHP-与-JSP-的交互？" class="headerlink" title="如何实现 PHP 与 JSP 的交互？"></a>如何实现 PHP 与 JSP 的交互？</h1><p>通过 SOAP、XML_RPC、Socket function 或者 CURL </p>
<p>都可以实现 PHP 与 JSP 的交互。如果是考 PHP 和 Java 的整合，则可以通过 PHP 内置的机制（如果考 PHP </p>
<p>和.NET 的整合，也可以这么回答），例如$php_java &#x3D; new Java(‘java.lang.System’);。</p>
<h1 id="开启-php-ini-文件中-safe-mode-选项，会影响到哪些函数的应用？至少说出-4-个"><a href="#开启-php-ini-文件中-safe-mode-选项，会影响到哪些函数的应用？至少说出-4-个" class="headerlink" title="开启 php.ini 文件中 safe_mode 选项，会影响到哪些函数的应用？至少说出 4 个"></a>开启 php.ini 文件中 safe_mode 选项，会影响到哪些函数的应用？至少说出 4 个</h1><p>pathinfo()、basename()、fopen()和 exec()等函数。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/15/PHP%E7%AC%94%E8%AF%95%E9%A2%98/" data-id="cmb0z941v0006usumc372h9wj" data-title="PHP笔试题" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-PHP面试题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/15/PHP%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2025-05-15T03:11:46.000Z" itemprop="datePublished">2025-05-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/PHP/">PHP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/05/15/PHP%E9%9D%A2%E8%AF%95%E9%A2%98/">PHP面试题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="PHP描述"><a href="#PHP描述" class="headerlink" title="PHP描述"></a>PHP描述</h1><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/PHP/9337">https://baike.baidu.com/item/PHP/9337</a></p>
<p>C语言开发的用于web网站建设的动态语言<br>从下到上4层处理：zend 引擎 + ext 扩展 + Sapi 接口 + php 程序</p>
<h1 id="高并发解决方案"><a href="#高并发解决方案" class="headerlink" title="高并发解决方案"></a>高并发解决方案</h1><p>流量优化：防盗链处理 将恶意请求屏蔽，</p>
<p>前端优化：页面缓存、限制大文件下载、图片压缩、减少http请求、添加异步请求、启用浏览器缓存和文件压缩、cdn加速、建立独立的图片服务器、</p>
<p>后端优化：  页面静态化、并发处理、队列处理、</p>
<p>服务器：nginx 反向代理、lvs 负载均衡，分流主机。</p>
<p>数据库优化： 数据库缓存、分库分表、分区操作 、读写分离、负载均衡</p>
<h1 id="session-和-cookie"><a href="#session-和-cookie" class="headerlink" title="session 和 cookie"></a>session 和 cookie</h1><p>session 服务端  安全  通过cookie 存储 sessionid  要先开启session  关闭浏览器结束会话,太多影响服务器性能<br>cookie  客户端 不安全 不占用服务器资源<br>重要信息session 、次要信息cookie、 cookie支持跨域名访问、session不支持跨域名访问</p>
<p>共享方案：<br>1：使用数据库保存session， 使用数据库来保存session，就算服务器宕机了也没事，session照样在。<br>问题：程序需要定制；每次请求都进行数据库读写开销不小，另外数据库是一个单点，可以做数据库的hash来解 决这个问题。</p>
<p>2：使用 memcached来保存session， 这种方式跟数据库类似，内存存取性能比数据库好很多。<br>  问题：程序需要定制，增加 了工作量；存入memcached中的数据都需要序列化，效率较低，断电或者重启电脑容易丢失数据；</p>
<p>3：使用 redis来保存session， 这种方式跟数据库类似，内存存取性能比数据库好很多。<br>问题：程序需要定制，增加 了工作量</p>
<p>4：通过加密的cookie，在A服务器上登录，在用户的浏览器上添加加密的cookie，当用户访问B服务器时，检查有无Session，如果没有，就检验 Cookie是否有效，Cookie有效的话就在B服务器上重建session。简单，高效， 服务器的压力减小了，因为session数据不存在服务器磁盘上。根本就不会出现session读取不到的问题。<br> 问题：网络请求占用很多。每次请求时，客户端都要通过cookie发送session数据给服务器，session中数据不能太多，浏览器对cookie 的大小存在限制。不适合高访问量的情况，因为高访问量的情况下。</p>
<h1 id="获取文件内容的方法"><a href="#获取文件内容的方法" class="headerlink" title="获取文件内容的方法"></a>获取文件内容的方法</h1><p>1：file_get_contents得到文件的内容（可以以get和post的方式获取），整个文件读入一个字符串中<br>2：用fopen打开url, 以get方式获取内容（借助fgets()函数）<br>3：用fsockopen函数打开url（可以以get和post的方式获取），以get方式获取完整的数据，包括header和body<br>4：使用curl库获取内容，使用curl库之前，需要查看php.ini，查看是否已经打开了curl扩展</p>
<h1 id="面向对象的特征有哪些方面"><a href="#面向对象的特征有哪些方面" class="headerlink" title="面向对象的特征有哪些方面?"></a>面向对象的特征有哪些方面?</h1><p>主要有封装,继承,多态。如果是4个方面则加上：抽象。<br>封装：（模块化）<br>封装是保证软件部件具有优良的模块性的基础,封装的目标就是要实现软件部件的高内聚,低耦合,防止程序相互依赖性而带来的变动影响.<br>继承：（重用）<br>在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性。<br>多态：(动态获取)<br>多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。<br>抽象：(共性)<br>抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面。例如，看到一只蚂蚁和大象，你能够想象出它们的相同之处，那就是抽象。</p>
<h1 id="OOP具有三大特点"><a href="#OOP具有三大特点" class="headerlink" title="OOP具有三大特点"></a>OOP具有三大特点</h1><p>1、封装性：也称为信息隐藏，就是将一个类的使用和实现分开，只保留部分接口和方法与外部联系，或者说只公开了一些供开发人员使用的方法。于是开发人员只 需要关注这个类如何使用，而不用去关心其具体的实现过程，这样就能实现MVC分工合作，也能有效避免程序间相互依赖，实现代码模块间松藕合。</p>
<p>2、继承性：就是子类自动继承其父级类中的属性和方法，并可以添加新的属性和方法或者对部分属性和方法进行重写。继承增加了代码的可重用性。PHP只支持单继承，也就是说一个子类只能有一个父类。</p>
<p>3、多态性：子类继承了来自父级类中的属性和方法，并对其中部分方法进行重写。于是多个子类中虽然都具有同一个方法，但是这些子类实例化的对象调用这些相同的方法后却可以获得完全不同的结果，这种技术就是多态性。多态性增强了软件的灵活性。</p>
<p>1、易维护</p>
<p>采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来是非常方便和较低成本的。</p>
<p>2、质量高</p>
<p>在设计时，可重用现有的，在以前的项目的领域中已被测试过的类使系统满足业务需求并具有较高的质量。</p>
<p>3、效率高</p>
<p>在软件开发时，根据设计的需要对现实世界的事物进行抽象，产生类。使用这样的方法解决问题，接近于日常生活和自然的思考方式，势必提高软件开发的效率和质量。</p>
<p>4、易扩展</p>
<p>由于继承、封装、多态的特性，自然设计出高内聚、低耦合的系统结构，使得系统更灵活、更容易扩展，而且成本较低。</p>
<h1 id="OOP思想，特征和其意义"><a href="#OOP思想，特征和其意义" class="headerlink" title="OOP思想，特征和其意义"></a>OOP思想，特征和其意义</h1><p>抽象、封装、继承和多态是面向对象的基础。</p>
<p>抽象：提取现实世界中某事物的关键特性，为该事物构建模型的过程。对同一事物在不同的需求下，需要提取的特性可能不一样。得到的抽象模型中一般包含：属性（数据）和操作（行为）。这个抽象模型我们称之为类。对类进行实例化得到对象。</p>
<p>封装：封装可以使类具有独立性和隔离性；保证类的高内聚。只暴露给类外部或者子类必须的属性和操作。类封装的实现依赖类的修饰符（public、protected和private等）</p>
<p>继承：对现有类的一种复用机制。一个类如果继承现有的类，则这个类将拥有被继承类的所有非私有特性（属性和操作）。这里指的继承包含：类的继承和接口的实现。</p>
<p>多态：多态是在继承的基础上实现的。多态的三个要素：继承、重写和父类引用指向子类对象。父类引用指向不同的子类对象时，调用相同的方法，呈现出不同的行为；就是类多态特性。多态可以分成编译时多态和运行时多态。</p>
<p>帮助理解: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/waj6511988/p/6974291.html">https://www.cnblogs.com/waj6511988/p/6974291.html</a></p>
<h1 id="OOP的七大设计原则是什么？"><a href="#OOP的七大设计原则是什么？" class="headerlink" title="OOP的七大设计原则是什么？"></a>OOP的七大设计原则是什么？</h1><ul>
<li>开闭原则：对扩展开放，对修改关闭</li>
<li>里氏替换原则：继承 必须保证 父类中的性质在子类中仍然成立</li>
<li>依赖倒置原则：面向接口编程，而不面向实现类</li>
<li>单一职责原则：控制 类的 粒度的大小 ，增强内聚性，减少耦合</li>
<li>接口隔离原则：要为各个类提供所需的专用接口</li>
<li>迪米特法则：迪米特法则（Law of Demeter）又叫作最少知识原则（The Least Knowledge Principle），一个类对于其他类知道的越少越好，就是说一个对象应当对其他对象有尽可能少的了解,只和朋友通信，不和陌生人说话。英文简写为: LOD。</li>
<li>合成复用原则：尽可能使用组合或者聚合等关系来关联类，其次才考虑使用继承。</li>
</ul>
<p>前五个合称 SOLID原则（单一职责原则、开放关闭原则、里氏替换原则、接口隔离原则和依赖倒置原则）</p>
<h1 id="GET-POST"><a href="#GET-POST" class="headerlink" title="GET&#x2F;POST"></a>GET&#x2F;POST</h1><p>get 请求一般用于向服务端获取数据，post 一般向服务端提交数据<br>get 传输的参数在 url 中，传递参数大小有限制，post 没有大小限制，<br>get 不安全，post 安全性比get高<br>get请求在服务端用Request.queryString 接受 ,post 请求在服务端用Requset.form 接受</p>
<h1 id="session与cookie的区别"><a href="#session与cookie的区别" class="headerlink" title="session与cookie的区别?"></a>session与cookie的区别?</h1><p>1、cookie数据存放在第三方应用的浏览器上，session数据放在服务器上。</p>
<p>2、cookie不是很安全，别人可以分析存放在本地的COOKIE，进行COOKIE欺骗,考虑到安全应当使用session。</p>
<p>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用COOKIE。</p>
<p>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p>
<p>5、所以个人建议：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将登陆信息等重要信息存放为SESSION</span><br><span class="line"></span><br><span class="line">其他信息如果需要保留，可以放在COOKIE</span><br></pre></td></tr></table></figure>

<h1 id="echo-print-print-r-的区别"><a href="#echo-print-print-r-的区别" class="headerlink" title="echo(),print(),print_r()的区别?"></a>echo(),print(),print_r()的区别?</h1><p>echo可以一次输出多个值，多个值之间用逗号分隔。echo是语言结构(language construct)，而并不是真正的函数，因此不能作为表达式的一部分使用。echo是php的内部指令，不是函数，无返回值。</p>
<p>print()：函数print()打印一个值（它的参数），如果字符串成功显示则返回true，否则返回false。只能打印出简单类型变量的值(如int,string)，有返回值</p>
<p>printf()：源于C语言中的printf()。该函数输出格式化的字符串。 </p>
<h1 id="print-r-和var-dump"><a href="#print-r-和var-dump" class="headerlink" title="print_r()和var_dump()"></a>print_r()和var_dump()</h1><p>print_r()可以把字符串和数字简单地打印出来，而数组则以括起来的键和值得列表形式显示，并以Array开头。但print_r()输出布尔值和NULL的结果没有意义，因为都是打印”\n”。因此用var_dump()函数更适合调试。print_r是函数，可以打印出比较复杂的变量(如数组，对象)，有返回值</p>
<p>var_dump()判断一个变量的类型与长度,并输出变量的数值,如果变量有值输的是变量的值并回返数据类型。此函数显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。</p>
<h1 id="说一下单引号双引号？"><a href="#说一下单引号双引号？" class="headerlink" title="说一下单引号双引号？"></a>说一下单引号双引号？</h1><p>①单引号内部的变量不会执行， 双引号会执行</p>
<p>②单引号解析速度比双引号快。</p>
<p>③单引号只能解析部分特殊字符，双引号可以解析所有特殊字符。</p>
<h1 id="echo-print-print-r"><a href="#echo-print-print-r" class="headerlink" title="echo(),print(),print_r()"></a>echo(),print(),print_r()</h1><p>echo是PHP语句, print和print_r是函数,语句没有返回值,函数可以有返回值(即便没有用)<br>print() 只能打印出简单类型变量的值(如int,string)<br>print_r() 可以打印出复杂类型变量的值(如数组,对象)<br>echo 输出一个或者多个字符串</p>
<h1 id="composer是什么？composer和PHP有什么关系？"><a href="#composer是什么？composer和PHP有什么关系？" class="headerlink" title="composer是什么？composer和PHP有什么关系？"></a>composer是什么？composer和PHP有什么关系？</h1><p>Composer是PHP的一个依赖（dependency）管理工具，在我们的项目中声明所依赖的外部工具库（libraries），Composer 可以帮助我们安装这些依赖的库文件。Composer可以全局安装也可以局部安装，默认不是全局安装的，是基于指定项目的某个目录进行安装的。</p>
<h1 id="composer团队协作怎么保证版本统一？"><a href="#composer团队协作怎么保证版本统一？" class="headerlink" title="composer团队协作怎么保证版本统一？"></a>composer团队协作怎么保证版本统一？</h1><p>安装组件使用composer install 而不是composer update，<br>.lock文件加入版本控制当中。</p>
<h1 id="框架中什么是单一入口和多入口-，-单一入口的优缺点？"><a href="#框架中什么是单一入口和多入口-，-单一入口的优缺点？" class="headerlink" title="框架中什么是单一入口和多入口 ， 单一入口的优缺点？"></a>框架中什么是单一入口和多入口 ， 单一入口的优缺点？</h1><p>多入口就是通过访问不同的文件来完成用户请求。单一入口指 web 程序所有的请求都指向一个脚本文件的。<br>单一入口更容易控制权限，方便对 http 请求可以进行安全性检查。<br>缺点：URL 看起来不那么美观，特别是对搜索引擎来说不友好。</p>
<p>单一入口的应用程序就是说用一个文件处理所有的HTTP请求。例如不管是列表页还是文章页，都是从浏览器访问index.php文件，这个文件就是这个应用程序的单一入口。</p>
<p>　　框架的多入口是指可以通过访问不同的PHP文件运行对应的功能，而不需要先访问指定的入口文件。</p>
<p>　　单一入口的优点：</p>
<p>　　1.由于所有的HTTP请求都由index.php接收，所以可以集中进行安全性检查，如果不是单一入口，那么开发者就必须在每一个文件的开头加上安全性检查代码。</p>
<p>　　2.还可以对URL参数和post方法进行必要的检查和对特殊字符过滤、记录日志、访问统计等各种可以集中处理的任务。</p>
<p>单一入口的缺点：</p>
<p>　　由于所有的HTTP请求都是针对index.php，所以程序的url看起来不美观，特别是对搜索引擎来说很不友好。</p>
<h1 id="怎么保证促销商品不会超卖"><a href="#怎么保证促销商品不会超卖" class="headerlink" title="怎么保证促销商品不会超卖?"></a>怎么保证促销商品不会超卖?</h1><p>答:这个问题是我们当时开发时遇到的一个难点，超卖的原因主要是下的订单的数目和我们要促销的商品的数目不一致导致的，每次总是订单的数比我们的促销商品的数目要多，当时我们的小组讨论了好久，给出了好几个方案来实现：</p>
<p>第一种方案：在每次下订单前我们判断促销商品的数量够不够，不够不允许下订单，更改库存量时加上一个条件，只更改商品库存大于0的商品的库存，当时我们使用ab进行压力测试，当并发超过500，访问量超过2000时，还是会出现超卖现象。所以被我们否定了。</p>
<p>第二种方案：使用mysql的事务加排他锁来解决，首先我们选择数据库的存储引擎为innoDB，使用的是排他锁实现的，刚开始的时候我们测试了下共享锁，发现还是会出现超卖的现象。有个问题是，当我们进行高并发测试时，对数据库的性能影响很大，导致数据库的压力很大，最终也被我们否定了。</p>
<p>第三种方案：使用文件锁实现。当用户抢到一件促销商品后先触发文件锁，防止其他用户进入，该用户抢到促销品后再解开文件锁，放其他用户进行操作。这样可以解决超卖的问题，但是会导致文件得I&#x2F;O开销很大。</p>
<p>最后我们使用了redis的队列来实现。将要促销的商品数量以队列的方式存入redis中，每当用户抢到一件促销商品则从队列中删除一个数据，确保商品不会超卖。这个操作起来很方便，而且效率极高，最终我们采取这种方式来实现</p>
<h1 id="商城秒杀的实现"><a href="#商城秒杀的实现" class="headerlink" title="商城秒杀的实现?"></a>商城秒杀的实现?</h1><p>答:抢购、秒杀是如今很常见的一个应用场景，主要需要解决的问题有两个：<br>1 高并发对数据库产生的压力<br>2 竞争状态下如何解决库存的正确减少（”超卖”问题）<br>对于第一个问题，已经很容易想到用缓存来处理抢购，避免直接操作数据库，例如使用Redis。<br>第二个问题，我们可以使用redis队列来完成，把要秒杀的商品放入到队列中，因为pop操作是原子的，即使有很多用户同时到达，也是依次执行，文件锁和事务在高并发下性能下降很快，当然还要考虑其他方面的东西，比如抢购页面做成静态的，通过ajax调用接口，其中也可能会出现一个用户抢多次的情况，这时候需要再加上一个排队队列和抢购结果队列及库存队列。高并发情况下，将用户进入排队队列，用一个线程循环处理从排队队列取出一个用户，判断用户是否已在抢购结果队列，如果在，则已抢购，否则未抢购，库存减1，写数据库，将用户入结果队列。</p>
<h1 id="TP的特性有哪些"><a href="#TP的特性有哪些" class="headerlink" title="TP的特性有哪些?"></a>TP的特性有哪些?</h1><p>答:TP框架是我们中国人自己开发的框架,各种资料比较齐全,国内用的比较多,比较简单和方便,而且是免费开源的</p>
<p>1.多表查询非常方便,在model中几句代码就可以完成对多表的关联操作</p>
<p>2.融合了smarty模板,使前后台分离</p>
<p>3.支持多种缓存技术,尤其对memcache技术支持非常好</p>
<p>4.命名规范,模型,视图,控制器严格遵循命名规则,通过命名一一对应</p>
<p>5.支持多种url模式</p>
<p>6.内置ajax返回方法,包括xml,json,html等</p>
<p>7.支持应用扩展,类库扩展,驱动扩展等</p>
<h1 id="TP框架中的大字母函数"><a href="#TP框架中的大字母函数" class="headerlink" title="TP框架中的大字母函数?"></a>TP框架中的大字母函数?</h1><p>U:对url的组装</p>
<p>A:内部实例化控制器</p>
<p>S:缓存处理</p>
<p>R:调用某个控制器的操作方法</p>
<p>D:实例化自定义模型类</p>
<p>M:实例化基础模型类</p>
<p>I:获取参数</p>
<p>L:设置或者获取当前语言</p>
<p>C:设置或获取,保存配置</p>
<h1 id="请介绍一下laravel框架"><a href="#请介绍一下laravel框架" class="headerlink" title="请介绍一下laravel框架?"></a>请介绍一下laravel框架?</h1><p>答: laravel框架的设计思想比较先进,非常适合应用各种开发模式,作为一个框架,它为你准备好了一切,composer是php的未来,没有composer,php肯定要走向没落</p>
<p>laravel框架最大的特点和优秀之处就是集合了php比较新的特点,以及各种各样的设计模式,Ioc模式,依赖注入等</p>
<p>14.laravel有那些特点?</p>
<p>回答一:</p>
<p>1.强大的rest router:用简单的回调函数就可以调用,快速绑定controller和router</p>
<p>2.artisan:命令行工具,很多手动的工作都自动化</p>
<p>3.可继承的模板,简化view的开发和管理</p>
<p>4.blade模板:渲染速度更快</p>
<p>5.ORM操作数据库</p>
<p>6.migration:管理数据库和版本控制</p>
<p>7.测试功能也很强大</p>
<p>8.composer也是亮点</p>
<p>回答二: laravel框架引入了门面,依赖注入,Ioc模式,以及各种各样的设计模式等</p>
<p>15.请简述一下数据库的优化?</p>
<p>答:数据库的优化可以从四个方面来优化:</p>
<p>1.从结构层: web服务器采用负载均衡服务器,mysql服务器采用主从复制,读写分离</p>
<p>2.从储存层: 采用合适的存储引擎,采用三范式</p>
<p>3.从设计层: 采用分区分表,索引,表的字段采用合适的字段属性,适当的采用逆范式,开启mysql缓存</p>
<p>4.sql语句层:结果一样的情况下,采用效率高,速度快节省资源的sql语句执行</p>
<p>16.如何解决异常处理?</p>
<p>答: 抛出异常:使用try…catch，异常的代码放在try代码块内，如果没有触发异常，则代码继续执行，如果异常被触发，就会 抛出一个异常。Catch代码块捕获异常，并创建一个包含异常信息的对象。$e-&gt;getMessage()，输出异常的错误信息。</p>
<p>解决异常:使用set_error_handler函数获取异常(也可以使用try()和catch()函数),然后使用set_exception_handler()函数设置默认的异常处理程序,register_shutdown_function()函数来执行,执行机制是,php要把调入的函数调入到内存,当页面所有的php语句都执行完成时,再调用此函数</p>
<h1 id="权限管理-RBAC-的实现"><a href="#权限管理-RBAC-的实现" class="headerlink" title="权限管理(RBAC)的实现?"></a>权限管理(RBAC)的实现?</h1><p>1.首先创建一张用户表:id name auto(保存格式为:控制器-方法)</p>
<p>2.然后在后台中创建一个基类控制器,控制器里封装一个构造方法,当用户登陆成功后,使用TP框架中封装好的session函数获取保存在服务器中的session id,然后实例化模型,通过用户id获取保存在数据表中的auth数据,使用explode函数分割获取到的数据,并使用一个数组保存起来,然后使用TP框架中封装好的常量获取当前控制器和方法,然后把他们组装成字符串,使用in_array函数进行判断该数组中是否含有当前获取到的控制器和方法,如果没有,就提示该用户没有权限,如果有就进行下一步操作</p>
<h1 id="支付功能的实现"><a href="#支付功能的实现" class="headerlink" title="支付功能的实现?"></a>支付功能的实现?</h1><h1 id="购物车的原理"><a href="#购物车的原理" class="headerlink" title="购物车的原理?"></a>购物车的原理?</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、把商品添加到购物车，即订购</span><br><span class="line"></span><br><span class="line">2、删除购物车中已定购的商品</span><br><span class="line"></span><br><span class="line">3、修改购物车中某一本图书的订购数量</span><br><span class="line"></span><br><span class="line">4、清空购物车</span><br><span class="line"></span><br><span class="line">5、显示购物车中商品清单及数量、价格</span><br></pre></td></tr></table></figure>

<p>实现购物车的关键在于服务器识别每一个用户并维持与他们的联系。但是HTTP协议是一种“无状态(Stateless)”的协议，因而服务器不能记住是谁在购买商品，当把商品加入购物车时，服务器也不知道购物车里原先有些什么，使得用户在不同页面间跳转时购物车无法“随身携带”，这都给购物车的实现造成了一定的困难。</p>
<p>目前购物车的实现主要是通过cookie、session或结合数据库的方式。下面分析一下它们的机制及作用。</p>
<p>cookie</p>
<p>cookie是由服务器产生，存储在客户端的一段信息。它定义了一种Web服务器在客户端存储和返回信息的机制，cookie文件它包含域、路径、生存期、和由服务器设置的变量值等内容。当用户以后访问同一个Web服务器时，浏览器会把cookie原样发送给服务器。通过让服务器读取原先保存到客户端的信息，网站能够为浏览者提供一系列的方便，例如在线交易过程中标识用户身份、安全要求不高的场合避免用户重复输入名字和密码、门户网站的主页定制、有针对性地投放广告等等。利用cookie的特性，大大扩展了WEB应用程序的功能，不仅可以建立服务器与客户机的联系，因为cookie可以由服务器定制，因此还可以将购物信息生成cookie值存放在客户端，从而实现购物车的功能。用基于cookie的方式实现服务器与浏览器之间的会话或购物车，有以下特点：</p>
<p>1、cookie存储在客户端，且占用很少的资源，浏览器允许存放300个cookie，每个cookie的大小为4KB，足以满足购物车的要求，同时也减轻了服务器的负荷；</p>
<p>2、cookie为浏览器所内置，使用方便。即使用户不小心关闭了浏览器窗口，只要在cookie定义的有效期内，购物车中的信息也不会丢失；</p>
<p>3、cookie不是可执行文件，所以不会以任何方式执行，因此也不会带来病毒或攻击用户的系统；</p>
<p>4、基于cookie的购物车要求用户浏览器必须支持并设置为启用cookie，否则购物车则失效；</p>
<p>5、存在着关于cookie侵犯访问者隐私权的争论，因此有些用户会禁止本机的cookie功能。</p>
<p>session</p>
<p>session是实现购物车的另一种方法。session提供了可以保存和跟踪用户的状态信息的功能，使当前用户在session中定义的变量和对象能在页面之间共享，但是不能为应用中其他用户所访问，它与cookie最重大的区别是，session将用户在会话期间的私有信息存储在服务器端，提高了安全性。在服务器生成session后，客户端会生成一个sessionid识别号保存在客户端，以保持和服务器的同步。这个sessionid是只读的，如果客户端禁止cookie功能，session会通过在URL中附加参数，或隐含在表单中提交等其他方式在页面间传送。因此利用session实施对用户的管理则更为安全、有效。</p>
<p>同样，利用session也能实现购物车，这种方式的特点是：</p>
<p>1、session用新的机制保持与客户端的同步，不依赖于客户端设置；</p>
<p>2、与cookie相比，session是存储在服务器端的信息，因此显得更为安全，因此可将身份标示，购物等信息存储在session中；</p>
<p>3、session会占用服务器资源，加大服务器端的负载，尤其当并发用户很多时，会生成大量的session，影响服务器的性能；</p>
<p>4、因为session存储的信息更敏感，而且是以文件形式保存在服务器中，因此仍然存在着安全隐患。</p>
<p>结合数据库的方式</p>
<p>这也是目前较普遍的模式，在这种方式中，数据库承担着存储购物信息的作用，session或cookie则用来跟踪用户。这种方式具有以下特点：</p>
<p>1、数据库与cookie分别负责记录数据和维持会话，能发挥各自的优势，使安全性和服务器性能都得到了提高；</p>
<p>2、每一个购物的行为，都要直接建立与数据库的连接，直至对表的操作完成后，连接才释放。当并发用户很多时，会影响数据库的性能，因此，这对数据库的性能提出了更高的要求；</p>
<p>3、使cookie维持会话有赖客户端的支持。</p>
<p>各种方式的选择：</p>
<p>虽然cookie可用来实现购物车，但必须获得浏览器的支持，再加上它是存储在客户端的信息，极易被获取，所以这也限制了它存储更多，更重要的信息。所以一般cookie只用来维持与服务器的会话，例如国内最大的当当网络书店就是用cookie保持与客户的联系，但是这种方式最大的缺点是如果客户端不支持cookie就会使购物车失效。</p>
<p>Session能很好地与交易双方保持会话，可以忽视客户端的设置。在购物车技术中得到了广泛的应用。但session的文件属性使其仍然留有安全隐患。</p>
<p>结合数据库的方式虽然在一定程度上解决了上述的问题，但从上面的例子可以看出：在这种购物流程中涉及到对数据库表的频繁操作，尤其是用户每选购一次商品，都要与数据库进行连接，当用户很多的时候就加大了服务器与数据库的负荷。</p>
<h1 id="你负责的模块有哪些难题"><a href="#你负责的模块有哪些难题" class="headerlink" title="你负责的模块有哪些难题?"></a>你负责的模块有哪些难题?</h1><p>答:在我负责的B2B电商项目中，当时我负责的是订单模块，由于客户一次选择了多家商户的商品，最终生成了一个订单，这样我们平台在给商户结算时出现了不知道这比费用应该给哪个商户，这时候我们小组经过讨论，需要涉及到订单拆分，也就是说用户点击支付后,如果有多件商品,并且不是同一家店铺那么 就要用到订单的拆分,比如如果有两件商品,并且不是同一店铺 就在原来的订单号下 在生成两个子订单号 并修改订单表中两件商品的订单号。最终实现了商品的分配管理，解决了我们的难题。</p>
<p>我觉得在开发过程中，遇到的难题无非是两个，一个是技术层次的，我认为，只要你有恒心，有热心，没有觉得不了的难题。另一个就是沟通问题，在任何地方任何时候沟通都是最重要的，尤其是我们做开发的，不沟通好，会影响整个项目的进度，我本人是个非常还沟通的人，所以这点上也没多大问题。</p>
<h1 id="用户下单是怎么处理的"><a href="#用户下单是怎么处理的" class="headerlink" title="用户下单是怎么处理的?"></a>用户下单是怎么处理的?</h1><p>答:判断用户有没有登录，在没有登录的情况下，不允许下单。登陆后，可进行下单,并生成唯一的订单号，此时订单的状态为未支付。</p>
<h1 id="电商的登录是怎么实现的"><a href="#电商的登录是怎么实现的" class="headerlink" title="电商的登录是怎么实现的?"></a>电商的登录是怎么实现的?</h1><p>答:分为普通登录和第三方登录 这边主要说一下第三方登录吧，第三方登陆主要使用的是author协议，我就以QQ的第三方登陆为例来进行说明：当用户在我们的站点请求QQ的第三方登陆时，我们站点会引导用户跳转到QQ的登陆授权界面， 当用户输入QQ和密码成功登录以后会自动跳回到我们站点设置好的回调页面，并附带一个code参数，接着你使用code再次去请求QQ的授权页面，就可以从中获取到一个access token（访问令牌），通过这个access_token，我们可以调用QQ提供给我们的接口，比如获取open_id，可以获取用户的基本信息。获取到之后，我们需要拿用户的授权信息和open_id和我们平台的普通用户进行绑定。这样不管是普通用户登陆还是第三方登陆用户，都可以实现登陆。</p>
<h1 id="在工作中遇到什么困难"><a href="#在工作中遇到什么困难" class="headerlink" title="在工作中遇到什么困难?"></a>在工作中遇到什么困难?</h1><p>答:总体来说：在工作我主要遇到这几个问题比较难处理：</p>
<p>①我之前工作的时候发现经常会出现一些临时需求打乱了我的计划，搞得有时候这个任务还没完成，又得去做其他的任务，最后一天下来，大大小小的东西是很多，但是没有完成得非常好的，后面我总结了一下，我会把这些都添加优先级，遇到临时需求，按照优先级重新将已有任务和临时任务进行排版，保证在规定时间内有效率的完成优先级高的任务。</p>
<p>②在做项目需求时候，遇到理解能力欠佳的人，沟通时容易被气到，影响自己的情绪，最后反倒还不能到达需要的效果。后面，每次到这种时候，我一般会借助一些纸质的、更加形象的东西，让双方都认同的、都能明白的一种方式来进行沟通，后面减少了很多不必须的麻烦。大家都知道，对于程序员来说，改需求是一件很痛苦的事情，所以前期的沟通工作很重要。</p>
<p>③还有一件事时，我以前的领导不太懂技术，所以每次出一个新的需求出来，总是要求我们在很短的时间内完成，完不成我们就会被怀疑能力有问题。当然，每个领导都希望自己的员工能够尽快的完成任务，降低成本，提高效率。这时候我会把我们的需求细化，把其中的重点、难点都列出来，做好时间规划，耐心的跟领导沟通，项目每个点的重要性和时间的花费比例，确保在这个规划的时间点内保质保量的完成任务。慢慢的也得到了领导的认可，其实领导也不是一味的不通情理，只要把东西计划好了，以最小的代价换取最高的价值，每个人都是很容易理解得</p>
<h1 id="写过接口吗，怎么定义接口的"><a href="#写过接口吗，怎么定义接口的" class="headerlink" title="写过接口吗，怎么定义接口的?"></a>写过接口吗，怎么定义接口的?</h1><p>答：写过。接口分为两种：一种是数据型接口，一种是应用型接口。</p>
<p>数据型接口：是比抽象类更抽象的某种“结构”——它其实不是类，但是跟类一样的某种语法结构，是一种结构规范，规范我们类要以什么格式进行定义，一般用于团队比较大，分支比较多的情况下使用。</p>
<p>应用型接口： API（application interface） 数据对外访问的一个入口</p>
<p>我主要是参与的APP开发中接口的编写，客户端需要什么样的数据，我们就给他们提供相应的数据，数据以json&#x2F;xml的格式返回，并且配以相应的接口文档。</p>
<h1 id="sku减库存"><a href="#sku减库存" class="headerlink" title="sku减库存?"></a>sku减库存?</h1><p>答:SKU &#x3D; Stock Keeping Unit (库存量单位)</p>
<p>即库存进出计量的单位，可以是以件，盒，托盘等为单位。SKU是库存量单位，区分单品。</p>
<p>在服装、鞋类商品中使用最多最普遍。 例如纺织品中一个SKU通常表示：规格、颜色、款式。</p>
<p>在设计表时，不仅仅只有商品表，商品表中有个总库存，我们还需要涉及一张SKU表，里面有SKU库存和单价字段，用户每购买一件商品，实际上购买的都是SKU商品，这样在下订单成功后，应该根据所购买的商品的唯一的SKU号来进行相应的SKU库存的减少，当然商品的总库存保存在商品主表中，也需要减少总库存中的库存量。</p>
<h1 id="库存设置？"><a href="#库存设置？" class="headerlink" title="库存设置？"></a>库存设置？</h1><p>答:库存分为商品总库存和SKU库存，往往商品总库存的为SKU库存的总和。一般在商城的后台对货品设置最高库存及最低库存后，当前库存数量与最高、最低两者比较，超出库存或者低于库存的，则被统计成报表形式反映，便于用户掌握货品库存超、短缺状态及数量。</p>
<h1 id="订单、库存两个表-如何保证数据的一致性？"><a href="#订单、库存两个表-如何保证数据的一致性？" class="headerlink" title="订单、库存两个表 如何保证数据的一致性？"></a>订单、库存两个表 如何保证数据的一致性？</h1><p>答：在一个电子商务系统中，正常的应该是订单生成成功后，相应的库存进行减少必须要保证两者的一致性，但有时候因为某些原因，比如程序逻辑问题，并发等问题，导致下单成功而库存没有减少的情况。这种情况我们是不允许发生的，MySQL的中的事务刚好可以解决这一问题，首先得选择数据库的存储引擎为InnoDB的，事务规定了只有下订单完成了，并且相应的库存减少了才允许提交事务，否则就事务回滚，确保数据一致性。</p>
<h1 id="O2O用户下单，c端下单，如何保证ba端数据一致？"><a href="#O2O用户下单，c端下单，如何保证ba端数据一致？" class="headerlink" title="O2O用户下单，c端下单，如何保证ba端数据一致？"></a>O2O用户下单，c端下单，如何保证ba端数据一致？</h1><p>答：O2O为线上和线下模式，O2O模式奉行的是“线上支付+实体店消费”的消费模式，即消费者在网上下单完成支付后，凭消费凭证到实体店消费。 O2O模式是把商家信息和支付程序放在线上进行，而把商品和服务兑现放在线下，也就是说O2O模式适用于快递无法送达的有形产品。数据一致性的问题是O2O行业中最常见的问题，我们可以类似于数据库的主从复制的思路来解决这个问题.O2O有个供应商系统，类似于主服务器，在ç端（从服务器）下单时，数据同步更新到供应商系统端，b，a实时从供应商系统中拉取数据进行同步，比如利用定时任务，定时拉取数据进行同步。</p>
<h1 id="秒杀当中的细节你是怎么得出来的"><a href="#秒杀当中的细节你是怎么得出来的" class="headerlink" title="秒杀当中的细节你是怎么得出来的?"></a>秒杀当中的细节你是怎么得出来的?</h1><p>答:通过性能测试及模拟秒杀场景。每个问题都经过反复测试，不断的发现问题，不断的解决。</p>
<h1 id="做秒杀用什么数据库，怎么实现的"><a href="#做秒杀用什么数据库，怎么实现的" class="headerlink" title="做秒杀用什么数据库，怎么实现的?"></a>做秒杀用什么数据库，怎么实现的?</h1><p>答:因为秒杀的一瞬间，并发非常大，如果同时请求数据库，会导致数据库的压力非常大，导致数据库的性能急剧下降，更严重的可能会导致数据库服务器宕机。这时候一般采用内存高速缓存数据库redis来实现的,redis是非关系型数据库，redis是单线程的，通过redis的队列可以完成秒杀过程。</p>
<h1 id="支付宝流程怎么实现的"><a href="#支付宝流程怎么实现的" class="headerlink" title="支付宝流程怎么实现的?"></a>支付宝流程怎么实现的?</h1><p>答:首先要有一个支付宝账号，接下来向支付宝申请在线支付业务，签署协议。协议生效后有支付宝一方会给网站方一个合作伙伴ID,和安全校验码，有了这两样东西就可以按照支付宝接口文档开发支付宝接口了，中间主要涉及到一个安全问题。整个流程是这样的：我们的网站通过post传递相应的参数（如订单总金额，订单号）到支付页面，支付页面把一系列的参数经过处理，以post的方式提交给支付宝服务器，支付宝服务器进行验证，并对接收的数据进行处理，把处理后的结果返回给我们网站设置的异步和同步回调地址，通过相应的返回参数，来处理相应的业务逻辑，比如返回的参数代表支付成功，更改订单状态。</p>
<h1 id="什么是单点登录？"><a href="#什么是单点登录？" class="headerlink" title="什么是单点登录？"></a>什么是单点登录？</h1><p>答:单点登录SSO（Single Sign On）说得简单点就是在一个多系统共存的环境下，用户在一处登录后，就不用在其他系统中登录，也就是用户的一次登录能得到其他所有系统的信任。</p>
<h1 id="什么情况下使用缓存"><a href="#什么情况下使用缓存" class="headerlink" title="什么情况下使用缓存?"></a>什么情况下使用缓存?</h1><p>答:当用户第一次访问应用系统的时候，因为还没有登录，会被引导到认证系统中进行登录；根据用户提供的登录信息，认证系统进行身份校验，如果通过校验，应该返回给用户一个认证的凭据－－ticket；用户再访问别的应用的时候，就会将这个ticket带上，作为自己认证的凭据，应用系统接受到请求之后会把 ticket送到认证系统进行校验，检查ticket的合法性。如果通过校验，用户就可以在不用再次登录的情况下访问应用系统2和应用系统3了。</p>
<p>实现主要技术点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、两个站点共用一个数据验证系统</span><br><span class="line"></span><br><span class="line">2、主要通过跨域请求的方式来实现验证及session处理。</span><br></pre></td></tr></table></figure>

<h1 id="怎么实现第三方登录？"><a href="#怎么实现第三方登录？" class="headerlink" title="怎么实现第三方登录？"></a>怎么实现第三方登录？</h1><p>答:第三方登陆主要是基于author协议来实现，下面简单说下实现流程:</p>
<p>1、首先我们需要以开发者的身份向第三方登陆平台申请接入应用，申请成功后，我们会获得一个appID和一个secrectID.</p>
<p>2、当我们的网站需接入第三方登陆时，会引导用户跳转到第三方的登陆授权页面，此时把之前申请的appID和secrectID带给登陆授权页面。</p>
<p>3、用户登陆成功后即得到授权，第三方会返回一个临时的code给我们的网站。</p>
<p>4、我们的网站接受到code后，再次向我们的第三方发起请求，并携带接收的code,从第三方获取access_token.</p>
<p>5、第三方处理请求后，会返回一个access_token给我们的网站，我们的网站获取到access_token后就可以调用第三方提供的接口了，比如获取用户信息等。最后把该用户信息存入到我们站点的数据库，并把信息保存到session中，实现用户的第三方登陆。</p>
<h1 id="如何处理负载、高并发？"><a href="#如何处理负载、高并发？" class="headerlink" title="如何处理负载、高并发？"></a>如何处理负载、高并发？</h1><p>答:从低成本、高性能和高扩张性的角度来说有如下处理方案：</p>
<p>1、HTML静态化</p>
<p>其实大家都知道，效率最高、消耗最小的就是纯静态化的html页面，所以我们尽可能使我们的 网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。</p>
<p>2、图片服务器分离</p>
<p>把图片单独存储，尽量减少图片等大流量的开销，可以放在一些相关的平台上，如骑牛等</p>
<p>3、数据库集群和库表散列及缓存</p>
<p>数据库的并发连接为100，一台数据库远远不够，可以从读写分离、主从复制，数据库集群方面来着手。另外尽量减少数据库的访问，可以使用缓存数据库如memcache、redis。</p>
<p>4、镜像：</p>
<p>尽量减少下载，可以把不同的请求分发到多个镜像端。</p>
<p>5、负载均衡：</p>
<p>Apache的最大并发连接为1500，只能增加服务器，可以从硬件上着手，如F5服务器。当然硬件的成本比较高，我们往往从软件方面着手。</p>
<p>负载均衡 （Load Balancing） 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力，同时能够提高网络的灵活性和可用性。目前使用最为广泛的负载均衡软件是Nginx、LVS、HAProxy。我分别来说下三种的优缺点:</p>
<p>Nginx的优点是：</p>
<p>工作在网络的7层之上，可以针对http应用做一些分流的策略，比如针对域名、目录结构，它的正则规则比HAProxy更为强大和灵活，这也是它目前广泛流行的主要原因之一，Nginx单凭这点可利用的场合就远多于LVS了。</p>
<p>Nginx对网络稳定性的依赖非常小，理论上能ping通就就能进行负载功能，这个也是它的优势之一；相反LVS对网络稳定性依赖比较大，这点本人深有体会；</p>
<p>Nginx安装和配置比较简单，测试起来比较方便，它基本能把错误用日志打印出来。LVS的配置、测试就要花比较长的时间了，LVS对网络依赖比较大。</p>
<p>可以承担高负载压力且稳定，在硬件不差的情况下一般能支撑几万次的并发量，负载度比LVS相对小些。</p>
<p>Nginx可以通过端口检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点，不过其中缺点就是不支持url来检测。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而不满。</p>
<p>Nginx不仅仅是一款优秀的负载均衡器&#x2F;反向代理软件，它同时也是功能强大的Web应用服务器。LNMP也是近几年非常流行的web架构，在高流量的环境中稳定性也很好。</p>
<p>Nginx现在作为Web反向加速缓存越来越成熟了，速度比传统的Squid服务器更快，可以考虑用其作为反向代理加速器。</p>
<p>Nginx可作为中层反向代理使用，这一层面Nginx基本上无对手，唯一可以对比Nginx的就只有 lighttpd了，不过 lighttpd目前还没有做到Nginx完全的功能，配置也不那么清晰易读，社区资料也远远没Nginx活跃。</p>
<p>Nginx也可作为静态网页和图片服务器，这方面的性能也无对手。还有Nginx社区非常活跃，第三方模块也很多。</p>
<p>Nginx的缺点是：</p>
<p>Nginx仅能支持http、https和Email协议，这样就在适用范围上面小些，这个是它的缺点。</p>
<p>对后端服务器的健康检查，只支持通过端口来检测，不支持通过url来检测。不支持Session的直接保持，但能通过ip_hash来解决。</p>
<p>LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability)、可靠性（Reliability)和可管理性（Manageability)。</p>
<p>LVS的优点是：</p>
<p>抗负载能力强、是工作在网络4层之上仅作分发之用，没有流量的产生，这个特点也决定了它在负载均衡软件里的性能最强的，对内存和cpu资源消耗比较低。</p>
<p>配置性比较低，这是一个缺点也是一个优点，因为没有可太多配置的东西，所以并不需要太多接触，大大减少了人为出错的几率。</p>
<p>工作稳定，因为其本身抗负载能力很强，自身有完整的双机热备方案，如LVS+Keepalived，不过我们在项目实施中用得最多的还是LVS&#x2F;DR+Keepalived。</p>
<p>无流量，LVS只分发请求，而流量并不从它本身出去，这点保证了均衡器IO的性能不会受到大流量的影响。</p>
<p>应用范围比较广，因为LVS工作在4层，所以它几乎可以对所有应用做负载均衡，包括http、数据库、在线聊天室等等。</p>
<p>LVS的缺点是：</p>
<p>软件本身不支持正则表达式处理，不能做动静分离；而现在许多网站在这方面都有较强的需求，这个是Nginx&#x2F;HAProxy+Keepalived的优势所在。</p>
<p>如果是网站应用比较庞大的话，LVS&#x2F;DR+Keepalived实施起来就比较复杂了，特别后面有 Windows Server的机器的话，如果实施及配置还有维护过程就比较复杂了，相对而言，Nginx&#x2F;HAProxy+Keepalived就简单多了。</p>
<p>HAProxy的特点是：</p>
<p>HAProxy也是支持虚拟主机的。</p>
<p>HAProxy的优点能够补充Nginx的一些缺点，比如支持Session的保持，Cookie的引导；同时支持通过获取指定的url来检测后端服务器的状态。</p>
<p>HAProxy跟LVS类似，本身就只是一款负载均衡软件；单纯从效率上来讲HAProxy会比Nginx有更出色的负载均衡速度，在并发处理上也是优于Nginx的。</p>
<p>HAProxy支持TCP协议的负载均衡转发，可以对MySQL读进行负载均衡，对后端的MySQL节点进行检测和负载均衡，大家可以用LVS+Keepalived对MySQL主从做负载均衡。</p>
<p>HAProxy负载均衡策略非常多，HAProxy的负载均衡算法现在具体有如下8种：</p>
<p>① roundrobin，表示简单的轮询，这个不多说，这个是负载均衡基本都具备的；</p>
<p>② static-rr，表示根据权重，建议关注；</p>
<p>③ leastconn，表示最少连接者先处理，建议关注；</p>
<p>④ source，表示根据请求源IP，这个跟Nginx的IP_hash机制类似，我们用其作为解决session问题的一种方法，建议关注；</p>
<p>⑤ ri，表示根据请求的URI；</p>
<p>⑥ rl_param，表示根据请求的URl参数’balance url_param’ requires an URL parameter name；</p>
<p>⑦ hdr(name)，表示根据HTTP请求头来锁定每一次HTTP请求；</p>
<p>⑧ rdp-cookie(name)，表示根据据cookie(name)来锁定并哈希每一次TCP请求。</p>
<p>Nginx和LVS对比的总结：</p>
<p>Nginx工作在网络的7层，所以它可以针对http应用本身来做分流策略，比如针对域名、目录结构等，相比之下LVS并不具备这样的功能，所以Nginx单凭这点可利用的场合就远多于LVS了；但Nginx有用的这些功能使其可调整度要高于LVS，所以经常要去触碰触碰，触碰多了，人为出问题的几率也就会大。</p>
<p>Nginx对网络稳定性的依赖较小，理论上只要ping得通，网页访问正常，Nginx就能连得通，这是Nginx的一大优势！Nginx同时还能区分内外网，如果是同时拥有内外网的节点，就相当于单机拥有了备份线路；LVS就比较依赖于网络环境，目前来看服务器在同一网段内并且LVS使用direct方式分流，效果较能得到保证。另外注意，LVS需要向托管商至少申请多一个ip来做Visual IP，貌似是不能用本身的IP来做VIP的。要做好LVS管理员，确实得跟进学习很多有关网络通信方面的知识，就不再是一个HTTP那么简单了。</p>
<p>Nginx安装和配置比较简单，测试起来也很方便，因为它基本能把错误用日志打印出来。LVS的安装和配置、测试就要花比较长的时间了；LVS对网络依赖比较大，很多时候不能配置成功都是因为网络问题而不是配置问题，出了问题要解决也相应的会麻烦得多。</p>
<p>Nginx也同样能承受很高负载且稳定，但负载度和稳定度差LVS还有几个等级：Nginx处理所有流量所以受限于机器IO和配置；本身的bug也还是难以避免的。</p>
<p>Nginx可以检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点。目前LVS中 ldirectd也能支持针对服务器内部的情况来监控，但LVS的原理使其不能重发请求。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而恼火。</p>
<p>Nginx对请求的异步处理可以帮助节点服务器减轻负载，假如使用 apache直接对外服务，那么出现很多的窄带链接时apache服务器将会占用大 量内存而不能释放，使用多一个Nginx做apache代理的话，这些窄带链接会被Nginx挡住，apache上就不会堆积过多的请求，这样就减少了相当多的资源占用。这点使用squid也有相同的作用，即使squid本身配置为不缓存，对apache还是有很大帮助的。</p>
<p>Nginx能支持http、https和email（email的功能比较少用），LVS所支持的应用在这点上会比Nginx更多。在使用上，一般最前端所采取的策略应是LVS，也就是DNS的指向应为LVS均衡器，LVS的优点令它非常适合做这个任务。重要的ip地址，最好交由LVS托管，比如数据库的 ip、webservice服务器的ip等等，这些ip地址随着时间推移，使用面会越来越大，如果更换ip则故障会接踵而至。所以将这些重要ip交给 LVS托管是最为稳妥的，这样做的唯一缺点是需要的VIP数量会比较多。Nginx可作为LVS节点机器使用，一是可以利用Nginx的功能，二是可以利用Nginx的性能。当然这一层面也可以直接使用squid，squid的功能方面就比Nginx弱不少了，性能上也有所逊色于Nginx。Nginx也可作为中层代理使用，这一层面Nginx基本上无对手，唯一可以撼动Nginx的就只有lighttpd了，不过lighttpd目前还没有能做到 Nginx完全的功能，配置也不那么清晰易读。另外，中层代理的IP也是重要的，所以中层代理也拥有一个VIP和LVS是最完美的方案了。具体的应用还得具体分析，如果是比较小的网站（日PV小于1000万），用Nginx就完全可以了，如果机器也不少，可以用DNS轮询，LVS所耗费的机器还是比较多的；大型网站或者重要的服务，机器不发愁的时候，要多多考虑利用LVS。</p>
<p>数据库优化</p>
<h1 id="做秒杀时锁表考虑到没有？"><a href="#做秒杀时锁表考虑到没有？" class="headerlink" title="做秒杀时锁表考虑到没有？"></a>做秒杀时锁表考虑到没有？</h1><p>答:考虑到了，当时我们做秒杀时考虑了好几种方案，其中有一种就是使用事务加上排他锁来实现。</p>
<h1 id="架构类的东西接触过吗？"><a href="#架构类的东西接触过吗？" class="headerlink" title="架构类的东西接触过吗？"></a>架构类的东西接触过吗？</h1><p>有接触过，曾经自己在自己的服务器上配置过。我以前做过以下几个架构方面的配置和测试;</p>
<p>1、数据库的读写分离、主从复制及集群。</p>
<p>2、Nginx负载均衡</p>
<p>3、redis集群及主从</p>
<h1 id="封装过一个简单的框架"><a href="#封装过一个简单的框架" class="headerlink" title="封装过一个简单的框架?"></a>封装过一个简单的框架?</h1><p>答;封装过一个简单的MVC框架,主要分为3层，控制器层和模型层视图层，以及路由的分配和入口文件，模板引擎，单例模式、工厂模式，第三方类库的引入等。</p>
<h1 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别?"></a>get和post的区别?</h1><ol>
<li>get是从服务器上获取数据，post是向服务器传送数据。</li>
<li>get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。</li>
<li>get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。</li>
<li>get安全性非常低，post安全性较高。但是执行效率却比Post方法好。</li>
</ol>
<h1 id="如何修改会话的生存时间？"><a href="#如何修改会话的生存时间？" class="headerlink" title="如何修改会话的生存时间？"></a>如何修改会话的生存时间？</h1><p>一：在php.ini中设置session.gc_maxlifetime &#x3D; 1440 &#x2F;&#x2F;默认时间</p>
<p>二：代码实现      $ lifeTime &#x3D; 24 * 3600; &#x2F;&#x2F;保存一天</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">session_set_cookie_params（$lifeTime）; </span><br><span class="line"></span><br><span class="line">在session_start（）;</span><br></pre></td></tr></table></figure>

<h1 id="接口和抽象类的区别是什么？"><a href="#接口和抽象类的区别是什么？" class="headerlink" title="接口和抽象类的区别是什么？"></a>接口和抽象类的区别是什么？</h1><p>答:抽象类是一种不能被实例化的类，只能作为其他类的父类来使用。抽象类是通过关键字abstract来声明的。 </p>
<p>抽象类与普通类相似，都包含成员变量和成员方法，两者的区别在于，抽象类中至少要包含一个抽象方法，抽象方法没有方法体，该方法天生就是要被子类重写的。 </p>
<p>抽象方法的格式为：abstract function abstractMethod();</p>
<p>接口是通过 interface 关键字来声明的，接口中的成员常量和方法都是 public 的，方法可以不写关键字public，接口中的方法也是没有方法体。接口中的方法也天生就是要被子类实现的。 </p>
<p>抽象类和接口实现的功能十分相似，最大的不同是接口能实现多继承。在应用中选择抽象类还是接口要看具体实现。 </p>
<p>子类继承抽象类使用 extends，子类实现接口使用implements。</p>
<h1 id="什么是队列？排它锁，Myisam死锁如何解决？"><a href="#什么是队列？排它锁，Myisam死锁如何解决？" class="headerlink" title="什么是队列？排它锁，Myisam死锁如何解决？"></a>什么是队列？排它锁，Myisam死锁如何解决？</h1><p>答:在默认情况下MYisam是表级锁，所以同时操作单张表的多个动作只能以队列的方式进行；</p>
<p>排它锁又名写锁，在SQL执行过程中为排除其它请求而写锁，在执行完毕后会自动释放；</p>
<p>死锁解决：先找到死锁的线程号，然后杀掉线程ID</p>
<h1 id="bootstrap框架有哪些优点"><a href="#bootstrap框架有哪些优点" class="headerlink" title="bootstrap框架有哪些优点?"></a>bootstrap框架有哪些优点?</h1><p>答:bootstrap是一款web开发框架,它由CSS,JavaScript,Html,三部分构成,它简洁灵活,使得web开发更加的快捷</p>
<p>优点: </p>
<p>①节省时间: 使用bootstrap框架,可以大大的节省项目开发时间,它包含了很多现成的代码,如果需要使用,只需要找到合适的代码,插入合适的位置即可,此外,CSS是使用LESS编写,很多样式和设计都已经设计完成了 </p>
<p>②定制化: bootstrap可以根据自己的项目,留取框架中自己需要的部分 </p>
<p>③设计合理:</p>
<p>栅格系统: bootstrap定义12格栅系统,在页面已经完成时,你可以根据合适的网格,以自己的需求改变行数和布局大小,样式已经开发完成了,只需要把代码放入合适的HTML代码位置即可</p>
<p>LESS: LESS是基于CSS之上的高级语言,其目的是使得CSS开发更加灵活,更加强大</p>
<p>JavaScript:bootstrap提供JavaScript库,该库超越了基本的架构和样式,开发者可以轻松的操作窗口警告框,工具提示框等,可避免了我们费神费力的写脚本 </p>
<p>4.一致性: bootstrap可以保证界面在不同平台的统一性,无论实在IE,Chrome等 </p>
<p>5.持续更新: bootstrap在不断的改进,更具规律性和持续性 </p>
<p>6.响应式: 无论是在PC端还是移动端,都可以保持界面的一致性 </p>
<p>7.文档多: bootstrap的非常多</p>
<h1 id="error-reporting的错误级别？"><a href="#error-reporting的错误级别？" class="headerlink" title="error reporting的错误级别？"></a>error reporting的错误级别？</h1><p>函数语法：error_reporting(report_level)</p>
<p>如果参数 level 未指定，当前报错级别将被返回。下面几项是 level 可能的值：</p>
<p>值 常量 描述</p>
<p>1 E_ERROR 致命的运行错误。错误无法恢复，暂停执行脚本。</p>
<p>2 E_WARNING 运行时警告(非致命性错误)。非致命的运行错误，脚本执行不会停止。</p>
<p>3 E_PARSE 编译时解析错误。解析错误只由分析器产生。</p>
<p>4 E_NOTICE 运行时提醒(这些经常是你代码中的bug引起的，也可能是有意的行为造成的。)</p>
<h1 id="语句中include和require的区别？"><a href="#语句中include和require的区别？" class="headerlink" title="语句中include和require的区别？**"></a>语句中include和require的区别？**</h1><p>require(“MyRequireFile.php”);这个函数通常放在 PHP 程序的最前面，PHP 程序在执行前，就会先读入 require 所指定引入的文件，使它变成 PHP 程序网页的一部份。</p>
<p>include(“MyIncludeFile.php”);这个函数一般是放在流程控制的处理部分中。PHP 程序网页在读到 include 的文件时，才将它读进来。</p>
<p>require一个文件存在错误的话，那么程序就会中断执行了，并显示致命错误include一个文件存在错误的话，那么程序不会中端，而是继续执行，并显示一个警告错误。</p>
<p>include有返回值，而require没有。</p>
<h1 id="php转义特殊字符的函数有哪些？"><a href="#php转义特殊字符的函数有哪些？" class="headerlink" title="php转义特殊字符的函数有哪些？"></a>php转义特殊字符的函数有哪些？</h1><p>php转义特殊字符的函数是：</p>
<p>1、addslashes()，使用反斜线引用字符串，对字符进行转义；解决sql注入问题。</p>
<p>2、mysql_real_escape_string()，转义SQL语句中使用的字符串中的特殊字符；</p>
<p>3、htmlspecialchars()。解决跨脚本攻击问题。</p>
<h1 id="什么是面向对象以及特点？"><a href="#什么是面向对象以及特点？" class="headerlink" title="什么是面向对象以及特点？"></a>什么是面向对象以及特点？</h1><p>（1）提到面向对象，自然会想到面向过程，面向过程就是分析解决问题所需要的步骤，然后用函数把这些步骤一一实现，使用的时候一个一个依次调用就可以了。面向对象则是把解决的问题按照一定规则划分为多个独立的对象，然后通过调用对象的方法来解决问题。当然，一个应用程序会包含多个对象，通过多个对象的相互配合来实现应用程序的功能，这样当应用程序功能发生变动时，只需要修改个别的对象就可以了，从而使代码更容易得到维护。</p>
<p>（2）面向对象的特点</p>
<p>面向对象的特点主要可以概括为封装性、继承性和多态性，接下来针对这三种特性进行简单介绍。</p>
<p>（3）封装是面向对象的核心思想，将对象的属性和行为封装起来，不需要让外界知道具体实现细节，这就是封装思想。</p>
<p>继承性主要描述的是类与类之间的关系，通过继承，可以在无须重新编写原有类的情况下，对原有类的功能进行扩展。</p>
<p>多态性指的是在程序中允许出现重名现象，它指在一个类中定义的属性和方法被其他类继承后，它们可以具有不同的数据类型或表现出不同的行为，这使得同一个属性和方法在不同的类中具有不同的语义。</p>
<h1 id="怎样实现一个静态化常用的设计模式？"><a href="#怎样实现一个静态化常用的设计模式？" class="headerlink" title="怎样实现一个静态化常用的设计模式？"></a>怎样实现一个静态化常用的设计模式？</h1><ol>
<li>动态URL地址设置静态形式（伪静态）</li>
<li>buffer</li>
</ol>
<p>　　　　buffer其实就是缓冲区，一个内存地址空间，主要用于存储数据区域。</p>
<p>　　　　编写一个buffer.php文件，并保存，并不是直接将文件内容保存在磁盘里，而是先把内容写入到buffer中，当一个buffer写满的时候，会把buffer中的数据写入到磁盘里，这是操作系统的buffer。</p>
<ol>
<li>PHP实现页面纯静态化</li>
</ol>
<p>　　　　纯静态化的html文件放在服务器端的磁盘。</p>
<ol>
<li>基本方式：</li>
</ol>
<p>　　　　file_put_contents()函数；</p>
<ol>
<li>ob函数</li>
</ol>
<p>　　　　ob_start(); 打开输出缓冲区</p>
<p>　　　　ob_get_contents(void);返回输出缓冲区内容</p>
<p>　　　　ob_clean(void);清空输出缓冲区</p>
<p>　　　　ob_get_clean(void);得到当前缓冲区的内容并删除当前输出缓冲区</p>
<ol>
<li>PHP处理伪静态：正则表达式匹配</li>
</ol>
<h1 id="tp框架的生命周期？"><a href="#tp框架的生命周期？" class="headerlink" title="tp框架的生命周期？"></a>tp框架的生命周期？</h1><p>（1）入口文件，</p>
<p>　　public&#x2F;index.php文件</p>
<p>（2）引导文件，</p>
<p>　　start.php文件就是系统默认的一个引导文件。start.php引导文件首先会调用base.php基础引导文件</p>
<p>（3）注册自动加载</p>
<p>　　系统会调用 Loader::register()方法注册自动加载</p>
<p>（4）注册错误和异常机制</p>
<p>​       执行Error::register()注册错误和异常处理机制。</p>
<p>（5）应用初始化</p>
<p>（6）URL访问检测</p>
<p>​       5.0的URL访问必须是PATH_INFO方式（包括兼容方式）的URL地址。</p>
<p>（7）路由检测</p>
<p>（8）分发请求</p>
<p>　　建议统一使用return返回数据，而不是echo输出，如非必要，请不要使用exit或者die中断执行。</p>
<p>（9）响应输出</p>
<p>　　控制器的所有操作方法都是return返回而不是直接输出，系统会调用Response::send方法将最终的应用返回的数据输出到页面或者客户端。</p>
<p>（10）应用结束</p>
<h1 id="类的自动加载怎么实现？"><a href="#类的自动加载怎么实现？" class="headerlink" title="类的自动加载怎么实现？"></a>类的自动加载怎么实现？</h1><p>​           A,手动include或者require.   B、spl_autoload_register()注册类到队列  C、开始实例化实用类</p>
<p>　　（1）使用__autoload方法，当程序中new一个没有直接引入的类的时候，php执行引擎会自动调用该方法。</p>
<p>　　（2）使用spl_autoload_register()，该函数可以注册给定的函数作为__autoload的实现，例如先把要加载的类作为该函数的参数注册到队列中，在调用__autoload的时候从队列中获取函数并引入，完成实例化。</p>
<p>　　（3）当使用多个spl_autoload_register方法时，php也会自动按顺序调用被注册的方法。</p>
<p>　　注：建议使用spl_autoload_register来实现类的自动加载，__autoload函数在更高版本的PHP中将被弃用。虽然性能和__FILE__魔术方法引入相对类路径的性能相近。但是自动加载机制可以防止或减少require_once，include_once在文件各处的随意使用类的查找顺序：优先查找手动include或require进来的类，查找不到的情况下再采用类的自动加载机制；</p>
<h1 id="composer的作用？"><a href="#composer的作用？" class="headerlink" title="composer的作用？"></a>composer的作用？</h1><p>　　　　composer的下载功能就是自动完成 下载 include 这两步，当然前提是这些代码包要符合 composer 对包的定义，这些定义是在包代码的项目根目录下的 composer.json 文件里面。</p>
<p>　　　　是php用来管理项目依赖的工具，用来下载项目中需要使用的外部工具库或叫组件。</p>
<p>　  （1）在项目根目录新建composer.json文件，主要用于声明组建依赖关系，类的自动加载来协助composer管理。</p>
<p>　　　　1、当键名是autoload时则会自动加载</p>
<p> 　　　   2、当键是require时则会下载或更新对应组件</p>
<p>　　　　3、composer.json文件必须都是双引号</p>
<p>　 （2）通过composer指定指令&#x2F;命令安装依赖关系所需组件,并初始化自动加载信息。</p>
<p>　　　　php composer.phar install</p>
<h1 id="tp和laravel的优缺点？"><a href="#tp和laravel的优缺点？" class="headerlink" title="tp和laravel的优缺点？"></a>tp和laravel的优缺点？</h1><p>　　（1）提交数据的方式，Laravel在提交表单时需要在表单中加入{csrf_field}来防止跨域攻击，而TP不会。</p>
<p>　　（2）路由，Laravel必须先定义，再使用，路由文件为routes.php，哪怕没有控制器方法,只要写了路由就能够访问。TP在配置文件中开启路由后，路由格式是：’路由表达式’ &#x3D;&gt; ‘路由地址和参数’（使用路由的前提是URL支持phthinfo并且开启路由），路由可以使URL更符合SEO。</p>
<p>　　（3）中间件，Laravel的中间件，可以实现访问前后的处理,中间件就是HTTP请求到达之前经过的层，通过中间件我们可以验证用户是否登录等一些通用操作。</p>
<p>　　（4）操作数据库方式，都可以使用实例化（建立相对应的模型类）和DB:table(‘表名’)来操作数据库，使用原生查询时不太相同，Laravel使用Db::操作(‘原生sql’)，TP使用Db::query(‘原生sql’)；</p>
<p>　　（5）Laravel升级十分简易，而TP大版本的升级要重构代码。</p>
<p>　　（6）渲染模版方式在Laravel框架里，使用return view()来渲染模版；而ThinkPHP里则使用了$this-&gt;display()的方式渲染模版</p>
<p>　　（7）条件判断语句书写方式</p>
<p>　　　　Laravel框架里 if else判断语句和foreach语句 书写时必须以@if开头 以@endif结尾,如果没有则报语法错误,@foreach @endforeach同理。而TP框架则和PHP语法规则使用方式一致直接ifesle语句判断和foreach循环遍历。</p>
<h1 id="什么是依赖注入？"><a href="#什么是依赖注入？" class="headerlink" title="什么是依赖注入？"></a>什么是依赖注入？</h1><p>　　在PHP中，依赖注入是指对类的依赖通过构造器完成自动注入，控制器架构方法和操作方法中一旦对参数进行对象类型约束则会自动除法依赖注入，由于访问控制器的参数都来自与URL请求，普通变量就是通过参数绑定自动获取，对象变量则是通过依赖注入生成。如果是类car想调用类bus里的plane方法，就需要在类car里实例化下类bus，然后在调用plane方法，这就是类car依赖于类bus。注入了plane方法。</p>
<h1 id="有用过预处理么？"><a href="#有用过预处理么？" class="headerlink" title="有用过预处理么？"></a>有用过预处理么？</h1><p>　　用过，PDO 类中，有个 prepare 方法可以实现预处理，PDOStament 类中的 excute方法可以执行预处理，预处理的参数分为两种，一种是:字符串占位符，另一种是?占位符，:字符串占位符在执行预处理传递参数时传入的是关联数组，而?占位符传递的是索引 数组。两者不能混合使用，但一般推荐使用:字符串占位符。</p>
<h1 id="php传值与传引用的区别是什么？"><a href="#php传值与传引用的区别是什么？" class="headerlink" title="php传值与传引用的区别是什么？"></a>php传值与传引用的区别是什么？</h1><p>　　传值在函数范围内，改变变量值的大小不会影响到函数外的变量值；传引用在函数范围内，对值的任何改变在函数外也有所体现，传引用传的是内存地址。这里有一点需要注意，将一个变量 &#x3D; 赋值给另一个变量时，不会立即为新变量分配内存空间，而是在原变量的zval中给refcount加1。 只有当原变量或者发生改变时，才会为新变量分配内存空间，同时原变量的refcount减 1 。当然，如果unset原变量，新变量直接就使用原变量的zval而不是重新分配。&amp;引用赋值时，原变量的is_ref 变为1，refcount 加1.  如果给一个变量&amp;赋值，之前 &#x3D; 赋值的变量会分配空间。</p>
<h1 id="如何实现session共享？"><a href="#如何实现session共享？" class="headerlink" title="如何实现session共享？"></a>如何实现session共享？</h1><p>　　　　服务器间Session同步定时同步各个服务器的session信息，此方法可能有一定延时，用户体验也不是很好。使用主-从服务器的架构，当用户在主服务器上登录后，通过脚本或者守护进程的方式，将session信息传递到各个从服务器中，也可以手工把session文件存放的目录改为nfs网络文件系统，从而实现文件的跨机器共享(使用nfs或windows文件共享都可以,或者专用的共享存储设备)。这样，用户访问其它的从服务器时，就可以读到session信息。</p>
<p>​              缺点：比如速度慢、不稳定等，另外，如果session信息传递是主-&gt;从单向的，会有一些风险，比如主服务器down了，其它服务器无法获得session信息。</p>
<h1 id="Git-常用命令速查？"><a href="#Git-常用命令速查？" class="headerlink" title="Git 常用命令速查？"></a>Git 常用命令速查？</h1><p>　　git branch 查看本地所有分支。</p>
<p>　　git status 查看当前状态。</p>
<p>　　git commit 提交。</p>
<p>　　git branch -a 查看所有的分支。</p>
<p>　　git branch -r 查看远程所有分支。</p>
<p>　　git push origin master 将本地项目给提交到服务器中</p>
<p>　　git pull 本地与服务器端同步</p>
<p>　　git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。</p>
<p>　　git init 本地初始化</p>
<h1 id="PHP如何实现静态化"><a href="#PHP如何实现静态化" class="headerlink" title="PHP如何实现静态化"></a>PHP如何实现静态化</h1><p>PHP的静态化分为：纯静态和伪静态。其中纯静态又分为：局部纯静态和全部纯静态。</p>
<p>PHP伪静态：利用Apache mod_rewrite实现URL重写的方法；</p>
<p>PHP纯静态，就是生成HTML文件的方式，我们须要开启PHP自带的缓存机制，即ob_start来开启缓存。</p>
<h1 id="PHP经典四大排序算法"><a href="#PHP经典四大排序算法" class="headerlink" title="PHP经典四大排序算法"></a>PHP经典四大排序算法</h1><p>PHP的四种基本排序算法为：冒泡排序、插入排序、选择排序和快速排序。</p>
<p>冒泡排序：对数组进行多轮冒泡，每一轮对数组中的元素两两比较，调整位置，冒出一个最大的数来。</p>
<p>插入排序：假设组前面的元素是排好序的，遍历数组后面的元素，在已排好序的元素队列中找到合适的位置，插入其中。</p>
<p>选择排序：进行多次选择，每次选出最大元素放入指定位置。</p>
<p>快速排序：递归算法。先选择数组的第一个元素作为标准，然后把小于或等于它和大于它的数分别放入两个数组中，对这两个数组也进行相同的处理，最后合并这两个数组和第一个元素。</p>
<h1 id="PHP常见运行模式"><a href="#PHP常见运行模式" class="headerlink" title="PHP常见运行模式"></a>PHP常见运行模式</h1><p>1）CGI（通用网关接口&#x2F; Common Gateway Interface）</p>
<p>2）FastCGI（常驻型CGI &#x2F; Long-Live CGI）lamp</p>
<p>3）CLI（命令行运行 &#x2F; Command Line Interface）</p>
<p>4）Web模块模式（Apache等Web服务器运行的模式）</p>
<p>5）ISAPI（Internet Server Application Program Interface）</p>
<h1 id="你了解设计模式吗？说下你最常用的设计模式"><a href="#你了解设计模式吗？说下你最常用的设计模式" class="headerlink" title="你了解设计模式吗？说下你最常用的设计模式"></a>你了解设计模式吗？说下你最常用的设计模式</h1><p>大概有23种设计模式，PHP常见的大概有10几种，虽然不算是基础，但是你必须要懂得。</p>
<p>总体来说设计模式分为三大类：</p>
<p>1、创建型模式共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>
<p>2、结构型模式共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>
<p>3、行为型模式共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
<p>观察者模式是如何实现的？工厂模式是如何实现的？适配器模式是如何实现的？……<br>观察者模式：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并且有所作为。即出版者+订阅者&#x3D;观察者模式。</p>
<p>工厂模式 ：将调用者和创建者分离，调用者直接向工厂类请求获取调用对象，减少代码耦合，提高系统的维护性和扩展性；</p>
<p>工厂模式应用场景：有多个产品类时就要用到工厂模式，比如在数据库连接中，我们可以采用多种数据库连接方法，有mysql扩展，mysqli扩展，PDO扩展等，在这种情况下我们可以一个扩展对应一个产品类，然后采用工厂模式。</p>
<p>适配器模式核心思想：把对某些相似的类的操作转化为一个统一的“接口”(这里是比喻的说话)–适配器，或者比喻为一个“界面”，统一或屏蔽了那些类的细节。适配器模式还构造了一种“机制”，使“适配”的类可以很容易的增减，而不用修改与适配器交互的代码，符合“减少代码间耦合”的设计原则。</p>
<h1 id="PHP的优化方案"><a href="#PHP的优化方案" class="headerlink" title="PHP的优化方案"></a>PHP的优化方案</h1><p>1.如果一个方法可静态化，就对它做静态声明。速率可提升至4倍。</p>
<p>2.echo 比 print 快。</p>
<p>3.使用echo的多重参数(译注：指用逗号而不是句点)代替字符串连接。</p>
<p>4.在执行for循环之前确定最大循环数，不要每循环一次都计算最大值。</p>
<p>5.注销那些不用的变量尤其是大数组，以便释放内存。</p>
<p>6.尽量避免使用__get，__set，__autoload。</p>
<p>7.require_once()代价昂贵。</p>
<p>8.在包含文件时使用完整路径，解析操作系统路径所需的时间会更少。</p>
<p>9.如果你想知道脚本开始执行(译注：即服务器端收到客户端请求)的时刻，使用$_SERVER[‘REQUEST_TIME’]要好于time()。</p>
<p>10.函数代替正则表达式完成相同功能。</p>
<p>11.str_replace函数比preg_replace函数快，但strtr函数的效率是str_replace函数的四倍。</p>
<p>12.如果一个字符串替换函数，可接受数组或字符作为参数，并且参数长度不太长，那么可以考虑额外写一段替换代码，使得每次传递参数是一个字符，而不是只写一行代码接受数组作为查询和替换的参数。</p>
<p>13.使用选择分支语句(译注：即switch case)好于使用多个if，else if语句。</p>
<p>14.用@屏蔽错误消息的做法非常低效。</p>
<p>15.打开apache的mod_deflate模块。</p>
<p>16.数据库连接当使用完毕时应关掉。</p>
<p>17.$row[‘id’]的效率是$row[id]的7倍。</p>
<p>18.错误消息代价昂贵。</p>
<p>19.尽量不要在for循环中使用函数，比如for ($x&#x3D;0; $x &lt; count($array); $x)每循环一次都会调用count()函数。</p>
<p>20.在方法中递增局部变量，速度是最快的。几乎与在函数中调用局部变量的速度相当。</p>
<p>21.递增一个全局变量要比递增一个局部变量慢2倍。</p>
<p>22.递增一个对象属性(如：$this-&gt;prop++)要比递增一个局部变量慢3倍。</p>
<p>23.递增一个未预定义的局部变量要比递增一个预定义的局部变量慢9至10倍。</p>
<p>24.仅定义一个局部变量而没在函数中调用它，同样会减慢速度(其程度相当于递增一个局部变量)。PHP大概会检查看是否存在全局变量。</p>
<p>25.方法调用看来与类中定义的方法的数量无关，因为我(在测试方法之前和之后都)添加了10个方法，但性能上没有变化。</p>
<p>26.派生类中的方法运行起来要快于在基类中定义的同样的方法。</p>
<p>27.调用带有一个参数的空函数，其花费的时间相当于执行7至8次的局部变量递增操作。类似的方法调用所花费的时间接近于15次的局部变量递增操作。</p>
<p>28.用单引号代替双引号来包含字符串，这样做会更快一些。因为PHP会在双引号包围的字符串中搜寻变量，单引号则不会</p>
<h1 id="说下你了解的session和cookie"><a href="#说下你了解的session和cookie" class="headerlink" title="说下你了解的session和cookie"></a>说下你了解的session和cookie</h1><p>1、存储位置不同</p>
<p>cookie的数据信息存放在客户端浏览器上。</p>
<p>session的数据信息存放在服务器上。</p>
<p>2、存储容量不同</p>
<p>单个cookie保存的数据&lt;&#x3D;4KB，一个站点最多保存20个Cookie。</p>
<p>对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制。</p>
<p>3、存储方式不同</p>
<p>cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。</p>
<p>session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。</p>
<p>4、隐私策略不同</p>
<p>cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的。</p>
<p>session存储在服务器上，对客户端是透明对，不存在敏感信息泄漏的风险。</p>
<p>5、有效期上不同</p>
<p>开发可以通过设置cookie的属性，达到使cookie长期有效的效果。</p>
<p>session依赖于名为JSESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果。</p>
<p>6、服务器压力不同</p>
<p>cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择。</p>
<p>session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存。</p>
<p>7、浏览器支持不同</p>
<p>假如客户端浏览器不支持cookie：</p>
<p>cookie是需要客户端浏览器支持的，假如客户端禁用了cookie，或者不支持cookie，则会话跟踪会失效。关于WAP上的应用，常规的cookie就派不上用场了。</p>
<p>运用session需要使用URL地址重写的方式,就是把session id附加在URL路径的后面，附加的方式也有两种，一种是作为URL路径的附加信息，另一种是作为查询字符串附加在URL后面。。一切用到session程序的URL都要进行URL地址重写，否则session会话跟踪还会失效。</p>
<p>假如客户端支持cookie：</p>
<p>cookie既能够设为本浏览器窗口以及子窗口内有效，也能够设为一切窗口内有效。</p>
<p>session只能在本窗口以及子窗口内有效。</p>
<p>8、跨域支持上不同</p>
<p>cookie支持跨域名访问。</p>
<p>session不支持跨域名访问。</p>
<p>如何实现不基于session和cookie的用户认证。<br>将用户信息加密放到http的header部分，每次拿到http的时候，验证获取header的信息。</p>
<h1 id="什么是CSRF攻击，XSS攻击？如何防范"><a href="#什么是CSRF攻击，XSS攻击？如何防范" class="headerlink" title="什么是CSRF攻击，XSS攻击？如何防范"></a>什么是CSRF攻击，XSS攻击？如何防范</h1><p>CSRF（Cross-site request forgery）跨站请求伪造,黑客建立一个伪造网站或发送邮箱带了一个正常URL链接来让正常用户访问，来让正常用户让自己浏览器里的COOKIE权限来执行一些非法请求，</p>
<p>如转账，提权等操作，</p>
<p>防范方法有，验证 HTTP Referer 字段；在请求地址中添加 token 并验证；</p>
<p>XSS攻击</p>
<p>主要将XSS代码提交存储在服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交XSS代码。当目标用户访问该页面获取数据时，XSS代码会从服务器解析之后加载出来，返回到浏览器做正常的HTML和JS解析执行，XSS攻击就发生了。</p>
<p>防范方法:通过过滤是针对非法的HTML代码包括单双引号等，使用htmlspecialchars()函数</p>
<p>你了解RESTful API吗？说说干什么用的。<br>RESTful API是REST风格的API，是一套用来规范多种形式的前端和同一个后台的交互方式的协议。RESTful API由后台也就是SERVER来提供前端来调用；前端调用API向后台发起HTTP请求，后台响应请求将处理结果反馈给前端。</p>
<h1 id="php设计模式六大原则"><a href="#php设计模式六大原则" class="headerlink" title="php设计模式六大原则"></a>php设计模式六大原则</h1><p>单一职责原则：不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。</p>
<p>开放封闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p>
<p>里氏替换原则：所有引用基类的地方必须能透明地使用其子类的对象。</p>
<p>接口隔离原则：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</p>
<p>迪米特原则：一个对象应该对其他对象保持最少的了解。</p>
<p>依赖倒置原则：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</p>
<h1 id="如何实现自动加载？不用composer如何实现？PSR-4是什么？"><a href="#如何实现自动加载？不用composer如何实现？PSR-4是什么？" class="headerlink" title="如何实现自动加载？不用composer如何实现？PSR-4是什么？"></a>如何实现自动加载？不用composer如何实现？PSR-4是什么？</h1><p>自动加载就是当我们在当前文件中实例化一个不存在的类时，调用自动加载机制引入相应的类文件。</p>
<p>注：自动加载有两种方式（都是php内置的），一种是通过__autoload(),另一种是通过spl_autoload_register()。</p>
<p>PSR是PHP Standards Recommendation的简称,制定的代码规范，简称PSR，是代码开发的事实标准。</p>
<p>PSR-4使代码更加规范，能够满足面向package的自动加载，它规范了如何从文件路径自动加载类，同时规范了自动加载文件的位置。</p>
<h1 id="抽象类和接口分别是什么-他们区别？"><a href="#抽象类和接口分别是什么-他们区别？" class="headerlink" title="抽象类和接口分别是什么,他们区别？"></a>抽象类和接口分别是什么,他们区别？</h1><p>抽象类：是基于类来说，其本身就是类，只是一种特殊的类，不能直接实例，可以在类里定义方法，属性。类似于模版，规范后让子类实现详细功能。</p>
<p>接口(Interface)—— 定义行为</p>
<p>抽象类(Abstract Class) —— 实现行为</p>
<p>具体类(class)——执行行为</p>
<p>接口：主要基于方法的规范，有点像抽象类里的抽象方法，只是其相对于抽象方法来说，更加独立。可让某个类通过组合多个方法来形成新的类。</p>
<p>抽象类与接口的相同点：</p>
<p>1、都是用于声明某一种事物，规范名称、参数，形成模块，未有详细的实现细节。</p>
<p>2、都是通过类来实现相关的细节工作</p>
<p>3、语法上，抽象类的抽象方法与接口一样，不能有方法体，即｛｝符号</p>
<p>4、都可以用继承，接口可以继承接口形成新的接口，抽象类可以继承抽象类从而形成新的抽象类</p>
<p>抽象类与接口的不同点：</p>
<p>1、抽象类可以有属性、普通方法、抽象方法，但接口不能有属性、普通方法、可以有常量</p>
<p>2、抽象类内未必有抽象方法，但接口内一定会有“抽象”方法</p>
<p>3、语法上有不同</p>
<p>4、抽象类用abstract关键字在类前声明，且有class声明为类，接口是用interface来声明，但不能用class来声明，因为接口不是类。</p>
<p>5、抽象类的抽象方法一定要用abstract来声明，而接口则不需要</p>
<p>6、抽象类是用extends关键字让子类继承父类后，在子类实现详细的抽象方法。而接口则是用implements让普通类在类里实现接口的详细方法，且接口可以一次性实现多个方法，用逗号分开各个接口就可</p>
<h1 id="微服务的了解"><a href="#微服务的了解" class="headerlink" title="微服务的了解"></a>微服务的了解</h1><p>概念：又称微服务架构，是一种架构风格，它将应用程序构建为以业务领域为模型的小型自治服务集合 。</p>
<p>优势：</p>
<p>独立开发 – 所有微服务都可以根据各自的功能轻松开发</p>
<p>独立部署 – 基于其服务，可以在任何应用程序中单独部署它们</p>
<p>故障隔离 – 即使应用程序的一项服务不起作用，系统仍可继续运行</p>
<p>混合技术堆栈 – 可以使用不同的语言和技术来构建同一应用程序的不同服务</p>
<p>粒度缩放 – 单个组件可根据需要进行缩放，无需将所有组件缩放在一起</p>
<p>特点：</p>
<p>解耦 – 系统内的服务很大程度上是分离的。因此，整个应用程序可以轻松构建，更改和扩展</p>
<p>组件化 – 微服务被视为可以轻松更换和升级的独立组件</p>
<p>业务能力 – 微服务非常简单，专注于单一功能</p>
<p>自治 – 开发人员和团队可以彼此独立工作，从而提高速度</p>
<p>持续交付 – 通过软件创建，测试和批准的系统自动化，允许频繁发布软件</p>
<p>责任 – 微服务不关注应用程序作为项目。相反，他们将应用程序视为他们负责的产品</p>
<p>分散治理 – 重点是使用正确的工具来做正确的工作。这意味着没有标准化模式或任何技术模式。开发人员可以自由选择最有用的工具来解决他们的问题</p>
<p>敏捷 – 微服务支持敏捷开发。任何新功能都可以快速开发并再次丢弃</p>
<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>php7的垃圾回收包含两个部分，一个是垃圾收集器，一个是垃圾回收算法。</p>
<p>垃圾收集器，把刚刚提到的，可能是垃圾的元素收集到回收池中 也就是把变量的 zend_refcount&gt;0的变量 放在回收池中。 当回收池的值达到一定额度了，会进行统一遍历处理。进行模拟删除，如果zend_refcount&#x3D;0那就认为是垃圾，直接删除它。 遍历回收池中的每一个变量，根据每一个变量，再遍历每一个成员，如果成员还有嵌套的话继续遍历。然后把所有成员的 做模拟的 refcount -1。如果此时外部的变量的 引用次数为 0 。那么可以视为垃圾，清楚。如果大于0，那么恢复引用次数，并从垃圾回收池中取出。</p>
<h1 id="高并发解决方案-1"><a href="#高并发解决方案-1" class="headerlink" title="高并发解决方案"></a>高并发解决方案</h1><p>1、流量优化</p>
<p>防盗链处理(去除恶意请求)</p>
<p>2、前端优化</p>
<p>(1) 减少HTTP请求[将css,js等合并]</p>
<p>(2) 添加异步请求(先不将所有数据都展示给用户,用户触发某个事件,才会异步请求数据)</p>
<p>(3) 启用浏览器缓存和文件压缩</p>
<p>(4) CDN加速</p>
<p>(5) 建立独立的图片服务器(减少I&#x2F;O)</p>
<p>3、服务端优化</p>
<p>(1) 页面静态化</p>
<p>(2) 并发处理</p>
<p>(3) 队列处理</p>
<p>4、数据库优化</p>
<p>(1) 数据库缓存</p>
<p>(2) 分库分表,分区</p>
<p>(3) 读写分离</p>
<p>(4) 负载均衡</p>
<p>5、web服务器优化</p>
<p>(1) nginx反向代理实现负载均衡</p>
<p>(2) lvs实现负载均衡</p>
<p>防止sql注入<br>防止注入的第一步就是验证数据，可以根据相应类型进行严格的验证。比如 int 类型直接同过 intval 进行转换就行：</p>
<p>参数化绑定，防止 SQL 注入的又一道屏障。php MySQLi 和 PDO 均提供这样的功能。比如 MySQLi 可以这样去查询：</p>
<p>魔术常量、超全局变量、魔术方法<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/t707584896/article/details/128798962">https://blog.csdn.net/t707584896/article/details/128798962</a></p>
<p>对象的克隆与引用有什么区别<br>引用就是：当改变$Object1对象时，$Object2也做相同的变化。</p>
<p>克隆就是：克隆的对象$Object1与原来的对象没有任何关系，它是将原来的对象从当前位置从新复制了一份。</p>
<p>什么是composer？composer的意义？工作原理<br>composer是一个依赖管理工具，composer会帮你安装这些依赖的库文件；</p>
<p>比如composer可以解决自动加载类，不用你写过多的new。</p>
<h1 id="说下一些你常用的linux命令"><a href="#说下一些你常用的linux命令" class="headerlink" title="说下一些你常用的linux命令"></a>说下一些你常用的linux命令</h1><p>1.pwd 命令 2.ls 命令 3.cd 命令 4.man 命令 5.grep 命令 6.find 命令 7.chmod 命令 8.ps 命令 9.kill 命令 10.tail 命令 11.netstat 命令 8.date 查看当前系统时间 10.echo 打印</p>
<p>多进程同时读写一个文件<br>$pid &#x3D; pcntl_fork();$fp &#x3D; fopen(“test.txt”, “a”);if (flock($fp, LOCK_EX)){ fwrite($fp, “content”); fflush($fp); flock($fp, LOCK_UN);}else{ echo “此文件正在被其他进程占用”;}</p>
<p>常用的服务端口号<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhanghongshun624/article/details/127920039">https://blog.csdn.net/zhanghongshun624/article/details/127920039</a></p>
<p>api接口的安全性设计<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/t707584896/article/details/129266951">https://blog.csdn.net/t707584896/article/details/129266951</a></p>
<p>如何防止数据重复提交，重复写入<br>主要从并发上面考虑：缓存、分流、redis锁、队列、mysql所有等方面</p>
<h1 id="SSO单点登陆"><a href="#SSO单点登陆" class="headerlink" title="SSO单点登陆"></a>SSO单点登陆</h1><p>在多个系统中，只需要登陆&#x2F;注销一次，就可以完成所有系统中的用户登陆验证。</p>
<p>同一个域名下的子域名各个系统可以使用设置顶级域名的cookie存储登陆信息来实现；</p>
<p>拦截登陆请求给用户中心发放令牌到子系统，子系统校验令牌后局部登陆，注销时用户中心发送请求到各个子系统注销局部登陆；</p>
<p>jwt，各个子系统使用相同的secret，相同的token可以在不同系统中使用；</p>
<p>以上方式的前提都要有统一的用户信息存储中心。</p>
<p>两台 mysql 服务器，其中一台挂了，怎么让业务端无感切换<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_36757755/article/details/124049382">https://blog.csdn.net/sinat_36757755/article/details/124049382</a></p>
<p>微服务之间怎么通信<br>1、基于网关 API</p>
<p>2、基于 RPC</p>
<p>3、基于 SideCar</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/452558073">https://zhuanlan.zhihu.com/p/452558073</a></p>
<h1 id="TCP三次握手四次挥手"><a href="#TCP三次握手四次挥手" class="headerlink" title="TCP三次握手四次挥手"></a>TCP三次握手四次挥手</h1><p>握手：</p>
<p>客户端请求服务端，发送连接请求标示和一串顺序码（X）</p>
<p>服务端收到请求，回复确认标示和顺序码（X）+1的确认码和另一个顺序码（Y）</p>
<p>客户端验证（X）+1确认码，通过后发送确认标示和（Y）+1的顺序码给服务端，服务端验证通过后建立连接</p>
<p>挥手：</p>
<p>第一次握手：TCP发送一个FIN(结束)，用来关闭客户到服务端的连接。</p>
<p>第二次握手：服务端收到这个FIN，他发回一个ACK(确认)，确认收到序号为收到序号+1。</p>
<p>第三次握手：服务端发送一个FIN(结束)到客户端，服务端关闭客户端的连接。</p>
<p>第四次握手：客户端发送ACK(确认)报文确认，并将确认的序号+1，这样关闭完成</p>
<p>为什么是四次不是三次？</p>
<p>server端收到结束请求后，需要等待数据传输完毕，所以只能先发送一个收到请求的确认信息给客户端，等数据传输完毕后再发送结束报文。</p>
<p>正常请求一个php网站，在浏览器输入网址打开网站，显示网页。但是在整个请求流程中浏览器做什么？服务器又是怎么在后台执行的？接下来就简单解析下一个完整的PHP请求的执行过程。<br>1、构建请求</p>
<p>2、查找缓存</p>
<p>3、域名解析</p>
<p>4、与服务器建立连接</p>
<p>TCP的三次握手</p>
<p>5、发起HTTP请求</p>
<p>6、服务器处理请求</p>
<p>7、服务器响应HTTP请求</p>
<p>8、客户端解析返回数据</p>
<p>9、与服务器断开连接</p>
<p>TCP的四次挥手</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43844718/article/details/126975557">https://blog.csdn.net/weixin_43844718/article/details/126975557</a></p>
<p>网络七层协议&#x2F;OSI七层模型</p>
<h1 id="swoole的了解"><a href="#swoole的了解" class="headerlink" title="swoole的了解"></a>swoole的了解</h1><p>技术特点：</p>
<p>1 常驻内存，避免重复加载带来的性能损耗，提升海量性能；</p>
<p>2 基于epoll，轻松支持高并发；</p>
<p>3 协程异步I&#x2F;O，提高对I&#x2F;O密集型场景并发处理能力；</p>
<p>4 支持多种通信协议，方便地开发 Http、WebSocket、TCP、UDP 等应用</p>
<h1 id="swoole与php-fpm对比有哪些优缺点？"><a href="#swoole与php-fpm对比有哪些优缺点？" class="headerlink" title="swoole与php-fpm对比有哪些优缺点？"></a>swoole与php-fpm对比有哪些优缺点？</h1><p>优点：</p>
<p>1 常驻内存的 cli 运行模式，不用每次请求加载一次项目代码</p>
<p>2 大大提高了对连接请求的并发能力</p>
<p>3 协程异步I&#x2F;O，提高对I&#x2F;O密集型场景并发处理能力</p>
<p>4 支持多种通信协议，能搭建 TCP&#x2F;UDP&#x2F;UnixSocket 服务器</p>
<p>5 原生支持毫秒定时器</p>
<p>缺点</p>
<p>1 相关文档较少</p>
<p>2 不支持 xdebug，不支持手动 dump，不熟悉相关工具的话，不太方便调试</p>
<p>3 入门难度高，多数 phper 不了解 TCP&#x2F;IP 网络协议、多进程 &#x2F; 多线程、异步 io 等</p>
<p>Nginx+Php-fpm运行原理<br><a target="_blank" rel="noopener" href="http://www.test.cc/">http://www.test.cc</a><br>        |<br>      Nginx<br>        |<br>路由到 <a target="_blank" rel="noopener" href="http://www.test.cc/index.php">http://www.test.cc/index.php</a><br>        |<br>加载nginx的fast-cgi模块<br>        |<br>fast-cgi监听127.0.0.1:9000地址<br>        |<br><a target="_blank" rel="noopener" href="http://www.test.com/index.php%E8%AF%B7%E6%B1%82%E5%88%B0%E8%BE%BE127.0.0.1:9000">www.test.com/index.php请求到达127.0.0.1:9000</a><br>        |<br>php-fpm 监听127.0.0.1:9000<br>        |<br>php-fpm 接收到请求，启用worker进程处理请求<br>        |<br>php-fpm 处理完请求并撤消内存，返回给nginx<br>        |<br>nginx 将结果通过http返回给浏览器</p>
<p>遇到一个网站打开慢怎么排查<br>1.打不开，则ping域名，看是否能请求成功。</p>
<p>2.慢，说明能打开，直接走这一步，free&#x2F;top命令查看服务器内存和CPU使用情况，iftop等工具查看带宽</p>
<p>3.chrome的debug-&gt;network查看响应慢的</p>
<p>4.排查响应慢的接口代码，看php，mysql，redis等的日志看错误信息（mysql的慢查询日志功能，php-fpm慢日志功能，需要配置开启）</p>
<p>高并发解决方案<br>1、流量优化</p>
<p>防盗链处理(去除恶意请求)</p>
<p>2、前端优化</p>
<p>(1) 减少HTTP请求[将css,js等合并]</p>
<p>(2) 添加异步请求(先不将所有数据都展示给用户,用户触发某个事件,才会异步请求数据)</p>
<p>(3) 启用浏览器缓存和文件压缩</p>
<p>(4) CDN加速</p>
<p>(5) 建立独立的图片服务器(减少I&#x2F;O)</p>
<p>3、服务端优化</p>
<p>(1) 页面静态化</p>
<p>(2) 并发处理</p>
<p>(3) 队列处理</p>
<p>4、数据库优化</p>
<p>(1) 数据库缓存</p>
<p>(2) 分库分表,分区</p>
<p>(3) 读写分离</p>
<p>5、web服务器优化</p>
<p>(1) 分布式部署</p>
<p>集群</p>
<p>(2) 负载均衡</p>
<p>如何选择消息队列？<br><a target="_blank" rel="noopener" href="https://blog.mimvp.com/article/47038.html">https://blog.mimvp.com/article/47038.html</a></p>
<h1 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ?"></a>什么是MQ?</h1><p>mq是一个消息队列,其主要目的是为了解决传统的消息传输上管理困难,效率不高的问题.</p>
<p>mq有三大优点:解耦,异步,削峰.</p>
<p>解耦: 如果是传统的消息通讯方式,无论是哪一方都要去维护一份供外部通讯的这个一个接口,而且各方处理消息的能力有限,效率上明显跟不上,并且这样子二者之间的耦合度非常高,对于拓展管理方面极不友好,而是要了mq就不一样,发送方只需要将消息发送给mq就可以了,别的不用考虑,接口什么的由mq去维护,接收方也只需要去mq里消费消息就可以了,就需要其他开销,一切由mq中间件来做,达到了解耦操作.</p>
<p>异步: 使用mq,还可以达到异步效果,极大地提升了消息传输的效率.发送方在发送消息后不需要关心消费方是否能消费完成,还可以继续发送其他消息.</p>
<p>削峰:如果是传统的消息通讯,一下子有大量的消息发送给接收方,这样对于接收方的处理压力是很大的,而我们刚好可以利用mq达到一个缓冲操作,一旦流量超出了接收方处理范围,不用担心,只需要慢慢消费即可,像经典的双十一,就很容易会使用到mq这么一个优点.</p>
<p>虽然mq有三大优点,但是我们还是得关心其一些缺点:</p>
<p>因为增加了中间件,系统复杂度肯定大大提高,增加了很多维护的成本,比如我们要保证消息不丢失(一致性)和消息幂等性问题,还要保证mq的高可用等.</p>
<p>mq消息队列如何保证消息的可靠性传输<br>消息的可靠性传输分为两个问题,一个是保证消息不被重复消费,另一个是保证消息不丢失.</p>
<p>保证消息不重复被消费,就是保证消息的幂等性问题,消息的幂等性是指一个操作执行任意多次所产生的影响均与一次执行的影响相同,在mq里,也就是消息只能被消费一次,不能被重复消费.</p>
<p>来看看消息丢失的场景:</p>
<p>发送方丢失,可能发送方在发送消息的过程中,出现网络问题等导致mq接收不到消息,导致了消息丢失.</p>
<p>要解决这个问题,首先可以采用事务机制,在发送消息的时候实现事务机制,若是出现发送失败的情况,可以进行回滚,而让消息重新被发送.但是开启了事务,发送方就必须同步等待事务执行完毕或者回滚,导致消息一多,性能会下降.</p>
<p>但是,还有一个更好的办法:可以采用确认机制,发送方在发送消息的时候必须要保证要收到一个确认消息,如果没有收到或者收到失败的确认消息,就说明消息发送失败,要重新进行发送,确认机制是可以采用异步进行的,这样就极大地保证了在保留效率的基础上又能保证消息的不丢失问题.</p>
<p>第二个丢失问题可能是在mq方发生的,如果mq没有进行持久化,出现了宕机关机等情况,消息就会丢失,解决办法无非就是将消息进行持久化,这样在出现问题的时候可以及时对消息进行恢复.</p>
<p>第三个丢失问题可能在消费方发生,这和发送方丢失问题类似,解决这个问题也是采用确认机制,这样一来就可以实现效率上的保证和消息不丢失的保证.</p>
<p>但是解决了这些问题,就会产生下面的幂等性问题:</p>
<p>我们都知道mq是可以进行重发的,且只有在它认为失败的情况会进行重发.什么时候mq会认为它发送给消费者的消息是失败的呢?也就是超出了它等待消费者响应的时间,这是一个超时时间,若是过了这个时间消费者仍然没有响应,说明mq发送失败,就会进行重试,而其实这个时候消费者可能是没有失败的,它只是因为某个原因导致消费超出了mq的等待时间而已,这个时候mq再发送一次消息,消费者就会重复消费.</p>
<p>实现幂等性消费:</p>
<p>MQ相关面试题<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_47303191/article/details/124693751">https://blog.csdn.net/weixin_47303191/article/details/124693751</a></p>
<p>MongoDB相关面试题<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/KangJinXuan/article/details/126936926">https://blog.csdn.net/KangJinXuan/article/details/126936926</a></p>
<h1 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h1><p>**显示有区别 **<br>get方法是将字符串拼接在地址栏后面可以看见<br>而post方法看不见</p>
<p>**传递的大小有区别 **<br>具体大小和浏览器有关系，ie浏览器是2k其他浏览器的最大值可能不同，但是也比较小。<br>而post方法传递参数的大小是可以设定的，原来是认为无限大。在PHP当中在php.ini文件是可以设置参数的大小的。</p>
<p>**安全性 **<br>get方法安全性比较低因为暴露在外面而post方法安全性比较高</p>
<p>**提交的原理 **<br>get方法提交的数据都是独立的。<br>而Post方法将所有的提交的数据变成一个整体（将提交的数据变成xml格式）</p>
<p><strong>灵活性</strong><br>get方法很灵活，<br>post方法不灵活，必须要有表单的参与才能用post提交很不方便</p>
<h1 id="常用的文件操作函数"><a href="#常用的文件操作函数" class="headerlink" title="常用的文件操作函数"></a>常用的文件操作函数</h1><p><strong>1. 获得文件名:</strong><br>basename — 返回路径中的文件名部分</p>
<p>$path &#x3D; “&#x2F;home&#x2F;cate&#x2F;index&#x2F;index2.php”;<br>$file &#x3D; basename($path);<br>echo $file; &#x2F;&#x2F;结果index2.php</p>
<p><strong>2. 获得目录名</strong><br>dirname — 返回路径中的目录部分</p>
<p>$path &#x3D; “&#x2F;home&#x2F;cate&#x2F;index&#x2F;index2.php”;<br>$file &#x3D; dirname($path);<br>echo $file;&#x2F;&#x2F;结果&#x2F;home&#x2F;cate&#x2F;index</p>
<p><strong>3.得到路径关联数组</strong><br>pathinfo() 函数以数组的形式返回关于文件路径的信息。<br>返回的数组元素如下：</p>
<ul>
<li></li>
<li></li>
<li></li>
<li><p>pathinfo(path,options)<br>| path | 必需。规定要检查的路径。<br>| options | 可选。规定要返回的数组元素。默认是 all。</p>
</li>
</ul>
<p>可能的值：</p>
<ul>
<li>PATHINFO_DIRNAME - 只返回 dirname</li>
<li>PATHINFO_BASENAME - 只返回 basename</li>
<li>PATHINFO_EXTENSION - 只返回 extension</li>
<li>PATHINFO_FILENAME - 只返回 filename</li>
</ul>
<h1 id="接口与抽象类的区别"><a href="#接口与抽象类的区别" class="headerlink" title="接口与抽象类的区别"></a>接口与抽象类的区别</h1><ol>
<li>接口<br>（1）对接口的使用是通过关键字implements<br>（2）接口不能定义成员变量（包括类静态变量），能定义常量<br>（3）子类必须实现接口定义的所有方法<br>（4）接口只能定义不能实现该方法<br>（5）接口没有构造函数<br>（6）接口中的方法和实现它的类默认都是public类型的</li>
<li>抽象类<br>（1）对抽象类的使用是通过关键字extends<br>（2）不能被实例化，可以定义子类必须实现的方法<br>（3）子类必须定义父类中的所有抽象方法，这些方法的访问控制必须和父类中一样（或者更为宽松）<br>（4）如一个类中有一个抽象方法，则该类必须定义为抽象类<br>（5）抽象类可以有构造函数<br>（6）抽象类中的方法可以使用private,protected,public来修饰。<br>（7）一个类可以同时实现多个接口，但一个类只能继承于一个抽象类。</li>
<li>Final类&#x2F;方法<br>（1）final类不能被继承<br>（2）final方法不能被重写</li>
<li>Static类&#x2F;方法<br>(1)可以不实例化类而直接访问<br>(2)静态属性不可以由对象通过-&gt;操作符来访问,用::方式调用</li>
</ol>
<h1 id="isset-empty-的区别"><a href="#isset-empty-的区别" class="headerlink" title="isset (),empty () 的区别"></a>isset (),empty () 的区别</h1><p>isset()：<br>若变量不存在则返回 FALSE<br>若变量存在且其值为NULL，也返回 FALSE<br>若变量存在且值不为NULL，则返回 TURE<br>同时检查多个变量时，每个单项都符合上一条要求时才返回 TRUE，否则结果为 FALSE </p>
<p>empty()：<br>若变量不存在则返回 TRUE<br>若变量存在且其值为””、0、”0”、NULL、、FALSE、array()、var $var; 以及没有任何属性的对象，则返回 TURE<br>若变量存在且值不为””、0、”0”、NULL、、FALSE、array()、var $var; 以及没有任何属性的对象，则返回 FALSE</p>
<h1 id="开发中应该注意哪些安全机制"><a href="#开发中应该注意哪些安全机制" class="headerlink" title="开发中应该注意哪些安全机制"></a>开发中应该注意哪些安全机制</h1><p>1.PHP配置<br>2.Sql注入，<br>3.Xss攻击（cross site script 跨站脚本），<br>4.盗链，<br>5.CSRF（跨站请求伪造cross site request forgery），<br>6.CC（是利用不断对网站发送连接请求致使形成拒绝服务的目的）</p>
<h1 id="大致说出浏览器通过-URL-访问的原理流程"><a href="#大致说出浏览器通过-URL-访问的原理流程" class="headerlink" title="大致说出浏览器通过 URL 访问的原理流程"></a>大致说出浏览器通过 URL 访问的原理流程</h1><p>1.键盘或触屏输入URL并回车确认<br>2.URL解析&#x2F;DNS解析查找域名IP地址<br>3.网络连接发起HTTP请求<br>4.HTTP报文传输过程<br>5.服务器接收数据<br>6.服务器响应请求&#x2F;MVC<br>7.服务器返回数据<br>8.客户端接收数据<br>9.浏览器加载&#x2F;渲染页面<br>10.打印绘制输出</p>
<h1 id="mysql-fetch-row-和-mysql-fetch-array-的区别"><a href="#mysql-fetch-row-和-mysql-fetch-array-的区别" class="headerlink" title="mysql_fetch_row () 和 mysql_fetch_array () 的区别"></a>mysql_fetch_row () 和 mysql_fetch_array () 的区别</h1><p>mysql_fetch_row() 从和结果标识 data 关联的结果集中取得一行数据并作为数组返回。每个结果的列储存在一个数组的单元中，偏移量从 0 开始。依次调用 mysql_fetch_row() 将返回结果集中的下一行，如果没有更多行则返回 FALSE。                                                     </p>
<p>mysql_fetch_array() 函数从结果集中取得一行作为关联数组，或数字数组，或二者兼有。</p>
<p>解释：<br>（1）如果你的表里面有字段a，b，c那么你用mysql_fetch_row()  就返回array（1&#x3D;&gt;a的值，2&#x3D;&gt;b的值，3&#x3D;&gt;c的值）这个时候你读数组的话，只能这样写$array[1],$array[2]才能得到a的值；</p>
<p>（2）要是用mysql_fetch_array()  就返回array（a&#x3D;&gt;a的值，b&#x3D;&gt;b的值，c&#x3D;&gt;c的值）和 array（1&#x3D;&gt;a的值，2&#x3D;&gt;b的值，3&#x3D;&gt;c的值）这个时候你读数组的话$array[1]和$array[a]都能得到a的值</p>
<h1 id="mvc框架的生命周期说一下"><a href="#mvc框架的生命周期说一下" class="headerlink" title="mvc框架的生命周期说一下"></a>mvc框架的生命周期说一下</h1><ul>
<li>model：存放向数据库请求来的数据</li>
<li>view：存放组件、图片、页面模板html文件</li>
<li>controller：获取或改变model里的数据返回给页面渲染数据</li>
</ul>
<p>用户请求进来，先加载配置文件，框架初始化，然后匹配路由地址，寻找到对应的controller的文件地址，引入加载文件，实例化controller，根据路由匹配得到的方法和参数，调用并传参到方法，此处可能需要读取db，model层则负责数据库存取，提供封装好的方法给到controller层调用，controller层得到数据后，通过引入view层文件，传递数据到view层，渲染html模板后输出。</p>
<h1 id="session与cookie"><a href="#session与cookie" class="headerlink" title="session与cookie"></a>session与cookie</h1><p>1、保持状态：</p>
<p>cookie和session都是用来跟踪浏览器用户身份的会话方式。<br>2、使用方式：<br>（1）cookie机制：如果不在浏览器中设置过期时间，cookie被保存在内存中，生命周期随浏览器的关闭而结束，这种cookie简称会话cookie。如果在浏览器中设置了cookie的过期时间，cookie被保存在硬盘中，关闭浏览器后，cookie数据仍然存在，直到过期时间结束才消失。</p>
<p>Cookie是服务器发给客户端的特殊信息，cookie是以文本的方式保存在客户端，每次请求时都带上它</p>
<p>（2）session机制：当服务器收到请求需要创建session对象时，首先会检查客户端请求中是否包含sessionid。如果有sessionid，服务器将根据该id返回对应session对象。如果客户端请求中没有sessionid，服务器会创建新的session对象，并把sessionid在本次响应中返回给客户端。通常使用cookie方式存储sessionid到客户端，在交互中浏览器按照规则将sessionid发送给服务器。如果用户禁用cookie，则要使用URL重写，可以通过response.encodeURL(url) 进行实现；API对encodeURL的结束为，当浏览器支持Cookie时，url不做任何处理；当浏览器不支持Cookie的时候，将会重写URL将SessionID拼接到访问地址后。</p>
<p>3、存储内容：</p>
<p>cookie只能保存字符串类型，以文本的方式；session通过类似与Hashtable的数据结构来保存，能支持任何类型的对象(session中可含有多个对象)</p>
<p>4、存储的大小：</p>
<p>cookie：单个cookie保存的数据不能超过4kb；</p>
<p>session大小没有限制。</p>
<p>5、安全性：</p>
<p>cookie：针对cookie所存在的攻击：Cookie欺骗，Cookie截获；<br>session的安全性大于cookie。</p>
<h1 id="为什么session的安全性大于cookie？"><a href="#为什么session的安全性大于cookie？" class="headerlink" title="为什么session的安全性大于cookie？"></a>为什么session的安全性大于cookie？</h1><ol>
<li>sessionID存储在cookie中，若要攻破session首先要攻破cookie；</li>
<li>sessionID是要有人登录，或者启动session_start才会有，所以攻破cookie也不一定能得到sessionID；</li>
<li>第二次启动session_start后，前一次的sessionID就是失效了，session过期后，sessionID也随之失效。</li>
<li>sessionID是加密的</li>
<li>综上所述，攻击者必须在短时间内攻破加密的sessionID，这很难。</li>
</ol>
<h1 id="session与cookie的应用场景有哪些？"><a href="#session与cookie的应用场景有哪些？" class="headerlink" title="session与cookie的应用场景有哪些？"></a>session与cookie的应用场景有哪些？</h1><p>cookie：<br>（1）判断用户是否登陆过网站，以便下次登录时能够实现自动登录（或者记住密码）。如果我们删除cookie，则每次登录必须从新填写登录的相关信息。<br>（2）保存上次登录的时间等信息。<br>（3）保存上次查看的页面。<br>（4）浏览计数。</p>
<p>session：</p>
<p>Session用于保存每个用户的专用信息，变量的值保存在服务器端，通过SessionID来区分不同的客户。</p>
<p>（1）网上商城中的购物车。<br>（2）保存用户登录信息。<br>（3）将某些数据放入session中，供同一用户的不同页面使用。<br>（4）防止用户非法登录。</p>
<h1 id="php7新特性"><a href="#php7新特性" class="headerlink" title="php7新特性"></a>php7新特性</h1><p>标量类型声明<br>返回值类型声明<br>语法糖：null合并运算符，太空船操作符<br>define允许定义常量数组，<br>匿名类，<br>新增了一些函数intdiv()，随机函数，</p>
<p><strong>1、php7.0相比于php5.6的新特性</strong></p>
<p>参考：<a target="_blank" rel="noopener" href="http://php.net/manual/zh/migration70.new-features.php">http://php.net/manual/zh/migration70.new-features.php</a></p>
<p><strong>2、php7.1相对于php7.0的新特性</strong></p>
<p>参考：<a target="_blank" rel="noopener" href="http://php.net/manual/zh/migration71.new-features.php">http://php.net/manual/zh/migration71.new-features.php</a></p>
<p><strong>3、php7.2相对于php7.1的新特性</strong></p>
<p>参考：<a target="_blank" rel="noopener" href="http://php.net/manual/zh/migration72.new-features.php">http://php.net/manual/zh/migration72.new-features.php</a></p>
<h1 id="php8新特性"><a href="#php8新特性" class="headerlink" title="php8新特性"></a>php8新特性</h1><p>新增联合类型（Union Types）；<br>添加了 WeakMap；<br>添加了 ValueError 类；<br>新增的特性大多是语法糖，主要是JIT。</p>
<p>JIT是一种编译器策略，它将代码表述为一种中间状态，在运行时将其转换为依赖于体系结构的机器码，并即时执行，在PHP8中，Zend VM不需要解释某些操作码，并且这些指令将直接作为CPU级指令执行。</p>
<p><strong>IT和opcache区别</strong></p>
<p>要说明opcode cache与JIT的区别，得先明白，<strong>字节码，又叫中间码与机器码的区别。</strong></p>
<p>简答的说，提升php执行效率，更快了。</p>
<p>JIT参考<a target="_blank" rel="noopener" href="https://www.laruence.com/2020/06/27/5963.html">鸟哥博客</a></p>
<h1 id="php垃圾回收机制"><a href="#php垃圾回收机制" class="headerlink" title="php垃圾回收机制"></a>php垃圾回收机制</h1><blockquote>
<p>关键词：使用了引用计数器</p>
</blockquote>
<ol>
<li>PHP可以自动进行内存管理,清除不需要的对象,主要使用了引用计数。</li>
<li>在zval结构体中定义了ref_count和is_ref , ref_count是引用计数 ,标识此zval被多少个变量引用 , 为0时会被销毁 。<br>is_ref标识是否使用的 &amp;取地址符强制引用。</li>
<li>为了解决循环引用内存泄露问题 , 使用同步周期回收算法。</li>
<li>当数组或对象循环的引用自身 , unset掉数组的时候 , 当refcount-1后还大于0的 , 就会被当成疑似垃圾 , 会进行遍历 ,并且模拟的删除一次refcount-1如果是0就删除 ,如果不是0就恢复。</li>
</ol>
<p>参考：<a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/features.gc.php">https://www.php.net/manual/zh/features.gc.php</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/15/PHP%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="cmb0z941w0007usumg68m8sax" data-title="PHP面试题" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PHP/" rel="tag">PHP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-PHP的魔术常量（变量）、魔术方法（函数）、超全局变量" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/14/PHP%E7%9A%84%E9%AD%94%E6%9C%AF%E5%B8%B8%E9%87%8F%EF%BC%88%E5%8F%98%E9%87%8F%EF%BC%89%E3%80%81%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%EF%BC%88%E5%87%BD%E6%95%B0%EF%BC%89%E3%80%81%E8%B6%85%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/" class="article-date">
  <time class="dt-published" datetime="2025-05-14T05:48:05.000Z" itemprop="datePublished">2025-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/05/14/PHP%E7%9A%84%E9%AD%94%E6%9C%AF%E5%B8%B8%E9%87%8F%EF%BC%88%E5%8F%98%E9%87%8F%EF%BC%89%E3%80%81%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%EF%BC%88%E5%87%BD%E6%95%B0%EF%BC%89%E3%80%81%E8%B6%85%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/">PHP的魔术常量（变量）、魔术方法（函数）、超全局变量</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="魔术常量（魔术变量）"><a href="#魔术常量（魔术变量）" class="headerlink" title="魔术常量（魔术变量）"></a>魔术常量（魔术变量）</h1><p>概念：所谓的魔术常量就是PHP预定义的一些常量，这些常量会随着所在的位置而变化。</p>
<p>1、_<em>LINE</em>_  获取文件中的当前行号。</p>
<p>2、_<em>FILE</em>_  获取文件的完整路径和文件名。</p>
<p>3、_<em>DIR</em>_   获取文件所在目录。</p>
<p>4、_<em>FUNCTION</em>_  获取函数名称（PHP 4.3.0 新加）。</p>
<p>5、_<em>CLASS</em>_    获取类的名称（PHP 4.3.0 新加）。</p>
<p>6、_<em>METHOD</em>_  获取类的方法名（PHP 5.0.0 新加）。</p>
<p>7、_<em>NAMESPACE</em>_ 当前命名空间的名称（区分大小写）。</p>
<p>8、_<em>TRAIT</em>_  Trait 的名字（PHP 5.4.0 新加）。自 PHP 5.4 起此常量返回 trait 被定义时的名字（区分大小写）。Trait 名包括其被声明的作用区域（例如 <em>Foo\Bar</em>）。</p>
<h1 id="超全局变量（9个）"><a href="#超全局变量（9个）" class="headerlink" title="超全局变量（9个）"></a>超全局变量（9个）</h1><p>1、$GLOBALS  ：储存全局作用域中的变量<br>2、$_SERVER  ：获取服务器相关信息<br>3、$_REQUEST ：获取POST和GET请求的参数<br>4、$_POST ： 获取表单的POST请求参数<br>5、$_GET： 获取表单的GET请求参数<br>6、$_FILES ：获取上传文件的的变量<br>7、$_ENV ： 获取服务器端环境变量的数组<br>8、$_COOKIE：获取浏览器的cookie<br>9、$_SESSION ： 获取session</p>
<h1 id="魔术方法（魔术函数）"><a href="#魔术方法（魔术函数）" class="headerlink" title="魔术方法（魔术函数）"></a>魔术方法（魔术函数）</h1><p>概念：PHP 将所有以 __（两个下划线）开头的类方法保留为魔术方法。所以在定义类方法时，除了上述魔术方法，建议不要以 __ 为前缀。</p>
<p>详情：<a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.oop5.magic.php">https://www.php.net/manual/zh/language.oop5.magic.php</a></p>
<h2 id="construct"><a href="#construct" class="headerlink" title="__construct()"></a>__construct()</h2><p>构造函数：每次创建新对象（实例化对象）时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。</p>
<p>应用笔记：如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用 <strong>parent::__construct()</strong>。</p>
<p>如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承（假如没有被定义为 private 的话）。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">print</span> <span class="string">&quot;In BaseClass constructor\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">BaseClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">parent</span>::<span class="title function_ invoke__">__construct</span>();</span><br><span class="line">		<span class="keyword">print</span> <span class="string">&quot;In SubClass constructor\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherSubClass</span> <span class="keyword">extends</span> <span class="title">BaseClass</span> </span>&#123;</span><br><span class="line">	<span class="comment">// inherits BaseClass&#x27;s constructor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In BaseClass constructor</span></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> <span class="title class_">BaseClass</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// In BaseClass constructor</span></span><br><span class="line"><span class="comment">// In SubClass constructor</span></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> <span class="title class_">SubClass</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// In BaseClass constructor</span></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> <span class="title class_">OtherSubClass</span>();</span><br></pre></td></tr></table></figure>

<h2 id="destruct"><a href="#destruct" class="headerlink" title="__destruct()"></a>__destruct()</h2><p>析构函数：析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。</p>
<p>和构造函数一样，父类的析构函数不会被引擎暗中调用。要执行父类的析构函数，必须在子类的析构函数体中显式调用 <strong>parent::__destruct()</strong>。此外也和构造函数一样，子类如果自己没有定义析构函数则会继承父类的。</p>
<p>析构函数即使在使用 <a target="_blank" rel="noopener" href="http://php.net/manual/zh/function.exit.php">exit()</a> 终止脚本运行时也会被调用。在析构函数中调用 <a target="_blank" rel="noopener" href="http://php.net/manual/zh/function.exit.php">exit()</a> 将会中止其余关闭操作的运行。</p>
<p>应用笔记：</p>
<p>1.析构函数在脚本关闭时调用，此时所有的 HTTP 头信息已经发出。脚本关闭时的工作目录有可能和在 SAPI（如 apache）中时不同。</p>
<p>2.试图在析构函数（在脚本终止时被调用）中抛出一个异常会导致致命错误。</p>
<h2 id="call"><a href="#call" class="headerlink" title="__call()"></a>__call()</h2><p>在对象中调用一个不可访问方法时，<a target="_blank" rel="noopener" href="http://php.net/manual/zh/language.oop5.overloading.php#object.call">__call()</a> 会被调用。</p>
<p>public <a target="_blank" rel="noopener" href="http://php.net/manual/zh/language.pseudo-types.php#language.types.mixed">mixed</a> <strong>__call</strong> ( string <code>$name</code> , array <code>$arguments</code> )</p>
<p>$name 参数是要调用的方法名称。$arguments 参数是一个枚举数组，包含着要传递给方法 $name 的参数。</p>
<h2 id="callStatic"><a href="#callStatic" class="headerlink" title="__callStatic()"></a>__callStatic()</h2><p>在对象中调用一个不可访问静态方法时，</p>
<p>在静态上下文中调用一个不可访问方法时，<a target="_blank" rel="noopener" href="http://php.net/manual/zh/language.oop5.overloading.php#object.callstatic">__callStatic()</a> 会被调用。</p>
<h2 id="set"><a href="#set" class="headerlink" title="__set()"></a>__set()</h2><p>在给不可访问属性赋值时，<a target="_blank" rel="noopener" href="http://php.net/manual/zh/language.oop5.overloading.php#object.set">__set()</a> 会被调用。</p>
<p>在给不可访问（protected 或 private）或不存在的属性赋值时，__set() 会被调用。</p>
<h2 id="get"><a href="#get" class="headerlink" title="__get()"></a>__get()</h2><p>读取不可访问属性的值时，<a target="_blank" rel="noopener" href="http://php.net/manual/zh/language.oop5.overloading.php#object.get">__get()</a> 会被调用。</p>
<p>读取不可访问（protected 或 private）或不存在的属性的值时，__get() 会被调用。</p>
<h2 id="isset"><a href="#isset" class="headerlink" title="__isset()"></a>__isset()</h2><p>当对不可访问属性调用 <a target="_blank" rel="noopener" href="http://php.net/manual/zh/function.isset.php">isset()</a> 或 <a target="_blank" rel="noopener" href="http://php.net/manual/zh/function.empty.php">empt()</a> 时，<a target="_blank" rel="noopener" href="http://php.net/manual/zh/language.oop5.overloading.php#object.isset">__isset()</a>会被调用。</p>
<p>当对不可访问（protected 或 private）或不存在的属性调用 isset() 或 empty() 时，__isset() 会被调用。</p>
<h2 id="unset"><a href="#unset" class="headerlink" title="__unset()"></a>__unset()</h2><p>当对不可访问属性调用 <a target="_blank" rel="noopener" href="http://php.net/manual/zh/function.unset.php">unset()</a> 时，<a target="_blank" rel="noopener" href="http://php.net/manual/zh/language.oop5.overloading.php#object.unset">__unset()</a> 会被调用。</p>
<p>当对不可访问（protected 或 private）或不存在的属性调用 unset() 时，__unset() 会被调用。</p>
<h2 id="sleep"><a href="#sleep" class="headerlink" title="__sleep()"></a>__sleep()</h2><p>方法常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。</p>
<p><a target="_blank" rel="noopener" href="http://php.net/manual/zh/function.serialize.php">serialize()</a> 函数会检查类中是否存在一个魔术方法 <a target="_blank" rel="noopener" href="http://php.net/manual/zh/language.oop5.magic.php#object.sleep">__sleep()</a>。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 <strong>NULL</strong> 被序列化，并产生一个 <strong>E_NOTICE</strong> 级别的错误。与之相反，<a target="_blank" rel="noopener" href="http://php.net/manual/zh/function.unserialize.php">unserialize()</a> 会检查是否存在一个 <a target="_blank" rel="noopener" href="http://php.net/manual/zh/language.oop5.magic.php#object.wakeup">__wakeup()</a> 方法。如果存在，则会先调用 <strong>__wakeup</strong> 方法，预先准备对象需要的资源。</p>
<h2 id="wakeup"><a href="#wakeup" class="headerlink" title="__wakeup()"></a>__wakeup()</h2><p><a target="_blank" rel="noopener" href="http://php.net/manual/zh/language.oop5.magic.php#object.wakeup">__wakeup()</a> ：经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。</p>
<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString()"></a>__toString()</h2><p><a target="_blank" rel="noopener" href="http://php.net/manual/zh/language.oop5.magic.php#object.tostring">__toString()</a> 方法用于一个类被当成字符串时回应。例如 <strong>echo $obj;</strong> 应该显示些什么。此方法必须返回一个字符串，否则将发出一条 <strong>E_RECOVERABLE_ERROR</strong> 级别的致命错误。</p>
<h2 id="invoke"><a href="#invoke" class="headerlink" title="__invoke()"></a>__invoke()</h2><p>当尝试以调用函数的方式调用一个对象时，<a target="_blank" rel="noopener" href="http://php.net/manual/zh/language.oop5.magic.php#object.invoke">__invoke()</a> 方法会被自动调用。（本特性只在 PHP 5.3.0 及以上版本有效）</p>
<h2 id="set-state"><a href="#set-state" class="headerlink" title="__set_state()"></a>__set_state()</h2><p><a target="_blank" rel="noopener" href="http://php.net/manual/zh/language.oop5.magic.php#object.set-state">__set_state()</a> ：自 PHP 5.1.0 起当调用 <a target="_blank" rel="noopener" href="http://php.net/manual/zh/function.var-export.php">var_export()</a> 导出类时，此<a target="_blank" rel="noopener" href="http://php.net/manual/zh/language.oop5.static.php">静态</a> 方法会被调用。本方法的唯一参数是一个数组，其中包含按 <strong>array(‘property’ &#x3D;&gt; value, …)</strong> 格式排列的类属性。</p>
<h2 id="clone"><a href="#clone" class="headerlink" title="__clone()"></a>__clone()</h2><p>对象复制。当复制完成时，如果定义了 <a target="_blank" rel="noopener" href="http://php.net/manual/zh/language.oop5.cloning.php#object.clone">__clone()</a> 方法，则新创建的对象（复制生成的对象）中的 <a target="_blank" rel="noopener" href="http://php.net/manual/zh/language.oop5.cloning.php#object.clone">__clone()</a> 方法会被调用，可用于修改属性的值（如果有必要的话）</p>
<h2 id="debugInfo"><a href="#debugInfo" class="headerlink" title="__debugInfo()"></a>__debugInfo()</h2><p>打印所需调试信息。</p>
<p>默认情况下，使用 print_r() 或 var_dump() 函数查看对象信息时，会显示对象的所有属性数据，包括公共的、私有的和受保护的。</p>
<p>可以自定义样式，如果限制（或简化）对象显示的信息，可以在类中定义 __debugInfo() 方法，它将返回一个数组，其中包含了对象属性的名称和数据。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/14/PHP%E7%9A%84%E9%AD%94%E6%9C%AF%E5%B8%B8%E9%87%8F%EF%BC%88%E5%8F%98%E9%87%8F%EF%BC%89%E3%80%81%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%EF%BC%88%E5%87%BD%E6%95%B0%EF%BC%89%E3%80%81%E8%B6%85%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/" data-id="cmb0z941s0003usum0g4c64e3" data-title="PHP的魔术常量（变量）、魔术方法（函数）、超全局变量" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/08/hello-world/" class="article-date">
  <time class="dt-published" datetime="2025-05-08T13:37:25.775Z" itemprop="datePublished">2025-05-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/05/08/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/08/hello-world/" data-id="cmb0z941u0005usumgzoybl2b" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/">PHP</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP/" rel="tag">PHP</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/PHP/" style="font-size: 10px;">PHP</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/05/15/Memcached%E9%9D%A2%E8%AF%95%E9%A2%98/">Memcached面试题</a>
          </li>
        
          <li>
            <a href="/2025/05/15/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/">Redis面试题</a>
          </li>
        
          <li>
            <a href="/2025/05/15/Nginx%E9%9D%A2%E8%AF%95%E9%A2%98/">Nginx面试题</a>
          </li>
        
          <li>
            <a href="/2025/05/15/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/">MySQL面试题</a>
          </li>
        
          <li>
            <a href="/2025/05/15/%E9%9D%A2%E8%AF%95/">面试</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>